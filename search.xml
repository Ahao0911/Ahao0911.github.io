<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Springboot笔记-1</title>
      <link href="/2022/12/29/Springboot%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2022/12/29/Springboot%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Springboot2-5学习笔记-1"><a href="#Springboot2-5学习笔记-1" class="headerlink" title="Springboot2.5学习笔记-1"></a>Springboot2.5学习笔记-1</h1><blockquote><p>三更草堂</p><p>参考三更老师笔记，仅供学习使用，侵删。</p></blockquote><hr><h2 id="1-Springboot是什么？"><a href="#1-Springboot是什么？" class="headerlink" title="1.Springboot是什么？"></a>1.Springboot是什么？</h2><ul><li>简化ssm</li><li>对spring的进一步封装。</li><li>提供了新特性：内嵌web容器，准备好的特性：指标，健康检查，外部化配置。</li><li><strong>最大特点：自动装配，起步依赖。</strong></li></ul><hr><h2 id="2-文档"><a href="#2-文档" class="headerlink" title="2.文档"></a>2.文档</h2><ul><li>推荐学习新技术的快速入门</li><li>不要通读文档，许多用不到</li></ul><hr><h2 id="3-清理Maven的小脚本（小技巧）"><a href="#3-清理Maven的小脚本（小技巧）" class="headerlink" title="3.清理Maven的小脚本（小技巧）"></a>3.清理Maven的小脚本（小技巧）</h2><ul><li><p>当网络不好或者其他原因时，maven下载的依赖不全或出错，进而导致项目出现问题。</p></li><li><p>所以需要这个小脚本来清理lastupdated文件夹，省去自己操作的繁琐。</p></li><li><p>如何使用？：创建.bat脚本文件，将代码换成自己的本地仓库地址，运行。</p></li><li><p>@echo off<br>rem create by NettQun</p><p>rem <em>这里写你的仓库路径（只有这里需要更改）</em><br>set REPOSITORY_PATH&#x3D;E:\Develop\maven_rep<br>rem 在搜索..<br>for &#x2F;f “delims&#x3D;” %%i in (‘dir &#x2F;b &#x2F;s “%REPOSITORY_PATH%*lastUpdated*”‘) do (<br>echo %<br>del &#x2F;s &#x2F;q “%%i”<br>)<br>rem 搜索完毕<br>pause</p></li></ul><hr><h2 id="4-创建工程以及准备环境"><a href="#4-创建工程以及准备环境" class="headerlink" title="4.创建工程以及准备环境"></a>4.创建工程以及准备环境</h2><ol><li>创建empty project</li><li>创建模块moudle，选择maven</li><li>注意java8，maven3.5以上版本</li></ol><hr><h2 id="5-快速入门"><a href="#5-快速入门" class="headerlink" title="5.快速入门"></a>5.快速入门</h2><ol><li><p>继承父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建启动类</p><ul><li><p>创建一个包com.xxx</p></li><li><p>在包中创建一个类并且加上<code>@SpringBootApplication</code>注解，标识为启动类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[]args)</span>&#123;</span><br><span class="line">SpringApplication.run (HelloApplication.class,args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplication.run (<code>类名（字节码对象）,args（main方法中的参数）</code>)</p><ol><li><p>各种层要创建在启动类所在的包及其子包下</p></li><li><p>在各种层加上注解，如控制层就为<code>@controller</code></p></li><li><p>在控制层内的方法上添加注解<code>@ResultMapping(&quot;/xxx&quot;)</code>指定请求地址</p></li><li><p>小细节：如果一个方法返回字符串，默认是会跳转到这个页面的，如果不想让他跳转而只想显示字符串内容：在方法上再添加<code>@ResponseBody</code>注解。</p><ul><li>还可以优化一下：如果所有返回字符串的方法都想显示在网页上，可以在类上添加注解<code>@controller</code>。</li><li>还可以优化，此时这个类上有@controller和@controller两个注解，可以优化成<code>@RestController</code>注解。</li></ul></li><li><p>启动，输入localhost：8080&#x2F;+<code>@RestController</code>中的路径，发送请求。</p></li><li><p>因为加上了@Response注解，所有响应的值会在响应体中看到，浏览器f12即可查看。</p><ul><li>controller层：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hel1o&quot;)</span></span><br><span class="line"><span class="keyword">public</span> string <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行启动类的main方法即可</p></li></ol></li></ol><hr><h2 id="6-常见问题以及解决方法"><a href="#6-常见问题以及解决方法" class="headerlink" title="6.常见问题以及解决方法"></a>6.常见问题以及解决方法</h2><ol><li>404无法访问：controller放在启动类所在包及其子包下</li><li>依赖爆红：配置阿里云镜像</li></ol><hr><h2 id="7-SpringBoot打包部署方式"><a href="#7-SpringBoot打包部署方式" class="headerlink" title="7.SpringBoot打包部署方式"></a>7.SpringBoot打包部署方式</h2><ol><li>添加maven插件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springboot打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>maven生命周期package打包，提示<code>build success</code>打包成功，去找打的包所在位置</li><li>在jar包所在的目录下进行cmd<code>java -jar  jar包名称</code>命令进行打包<ul><li>如果在打包过程中不小心点击到哪儿导致进度暂停（因为开启了快速编辑模式，点击页面使cmd认为要进行快速编辑），按下ctrl+c可继续进行</li></ul></li></ol><hr><h2 id="8-SpringBoot项目的快速搭建"><a href="#8-SpringBoot项目的快速搭建" class="headerlink" title="8.SpringBoot项目的快速搭建"></a>8.SpringBoot项目的快速搭建</h2><ol><li>在项目中创建新模块（moudle），选择Spring Initializr</li><li>选择default（本质是spring官方提供的<a href="https://start.spring.io/">快速生成网站</a>），next，设置对应信息</li><li>next，选择要添加的依赖Lombok，spring web， jdbc等。完成。</li><li>更推荐之前的方式</li></ol><hr><h2 id="9-起步依赖：依赖冲突及解决方案"><a href="#9-起步依赖：依赖冲突及解决方案" class="headerlink" title="9.起步依赖：依赖冲突及解决方案"></a>9.起步依赖：依赖冲突及解决方案</h2><ol><li><p>依赖冲突：一般程序在运行时发生类似于java.lang.ClassNotFoundException,Method not found:’…….’,或者莫名其妙的异常信息，这种情况一般很大可能就是j包依赖冲突的问题引起的了。一般在是A依赖C(低版本)，B也依赖C(高版本)。都是他们依赖的又是不同版本的C的时候会出现。</p></li><li><p>解决方案：</p><ul><li>如果出现了类似于java.lang.ClassNotFoundException,Method not found:这些异常检查相关的依赖冲突问<br>题，排除掉低版本的依赖，留下高版本的依赖。</li><li>点击maven的<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221226231940947.png" alt="image-20221226231940947">图标，即可查看依赖关系，会有红线方便排查项目。</li><li>maven helper插件，在idea底部也可以显示：进入插件，选中红色报错，右键exclude即可解决。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221226232426284.png" alt="image-20221226232426284"></li><li>然后refresh刷新</li><li>原理？-&gt;添加exclusions排除标签</li></ul></li><li><p>版本锁定：</p><ul><li><p>比如：以下这个依赖没有写版本号，为什么呢？</p></li><li><p>&#96;&#96;&#96;xml</p><parent>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-parent</artifactId>    <version>2.5.1</version></parent><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-web</artifactId>    </dependency></dependencies><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 因为父工程的dependency父工程已经规定好了，避免依赖冲突，并且好写。默认用父工程版本号</span><br><span class="line"></span><br><span class="line">- 也可以在子工程依赖中添加version标签，或者子工程properties标签下的xxx.version标签规定版本号，一般来说用父工程版本就行了。</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">  &lt;aspectj.version&gt;1.7.2&lt;/aspectj.version</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">      </span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>starter机制</p><ul><li><p>当我们需要使用某种功能时只需要引入对应的starterl即可。一个starter针对一种特定的场景，其内部引入了该<br>场景所需的依赖。这样我们就不需要单独引入多个依赖了。</p></li><li><p>命名规律：</p><ul><li><p>官方starter都是以<code>spring-boot-starter</code>开头后面跟上场景名称。例如：spring-boot-starter-data-jpa</p></li><li><p>非官方starterl则是以<code>场景名-spring-boot-starter</code>的格式，例如：mybatis-spring-boot-starter</p></li><li><p>官方不加版本号，非官方加</p></li><li><p>比如：下面这个starter包含许多依赖</p></li><li><p>&#96;&#96;&#96;xml</p><dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-web</artifactId></dependency><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">## 10.自动配置</span><br><span class="line"></span><br><span class="line">1. 约定优于配置：自动进行默认配置，不用做大量配置</span><br><span class="line">2. 如果有需要想要修改默认配置，可以修改这部分配置</span><br><span class="line">3. 如何自定义？源码解析</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 11.YAML/YML</span><br><span class="line"></span><br><span class="line">1. 简介：.yml后缀文件，序列化格式，专门用来写配置文件的语言，完成xml的任务，更简洁。</span><br><span class="line"></span><br><span class="line">2. 语法：</span><br><span class="line"></span><br><span class="line">   - `k: v`的键值对关系，**冒号后必须跟一个空格**。</span><br><span class="line"></span><br><span class="line">   - 空格缩进表示层级，缩进多少不重要，**左对齐的一列数据是同一层级数据。**</span><br><span class="line"></span><br><span class="line">     如：</span><br><span class="line"></span><br><span class="line">     ```yaml</span><br><span class="line">     student:</span><br><span class="line">         name: sangeng</span><br><span class="line">         age: 15</span><br><span class="line">     #name和age就是同一层级</span><br></pre></td></tr></table></figure></li></ul></li><li><p>大小写敏感，缩进不允许tab，只允许空格，idea可以空格。</p></li><li><p>java的驼峰命名，再yml中和-一样：lastName&#x3D;last-name</p></li><li><p>单引号不专义（只转义特殊字符），双引号转义。</p></li><li><p>日期： 年&#x2F;月&#x2F;日</p></li><li><p>对象：属性和值，Map:键值对</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多行写法</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sangeng</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">15</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#行内写法</span></span><br><span class="line"><span class="attr">student:</span> &#123;<span class="attr">name:</span> <span class="string">zhangsan</span>,<span class="attr">age:</span> <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组，list，set</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多行写法</span></span><br><span class="line"><span class="attr">pets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"><span class="comment"># 行内</span></span><br><span class="line"><span class="attr">pets:</span> [<span class="string">dog</span>,<span class="string">pig</span>,<span class="string">cat</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意 - xxx的空格，注意pets: []的空格</span></span><br></pre></td></tr></table></figure></li><li><p>对象数组、对象list、对象set</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">students:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">zhangsan</span><span class="comment">#多行</span></span><br><span class="line">   <span class="attr">age:</span> <span class="number">22</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lisi</span></span><br><span class="line">   <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"> <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">wangwu</span>,<span class="attr">age:</span> <span class="number">18</span>&#125;<span class="comment">#行内</span></span><br></pre></td></tr></table></figure></li><li><p>占位符赋值</p><p>使用 <strong>${key:defaultValue}</strong> 的方式来赋值，若key不存在，则会使用defaultValue来赋值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">$&#123;myPort:88&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="12-SpringBoot读取YML配置"><a href="#12-SpringBoot读取YML配置" class="headerlink" title="12.SpringBoot读取YML配置"></a>12.SpringBoot读取YML配置</h2><ol><li><p>@Value注解：此注解只能获取简单类型的值（8种基本数据类型及其包装类，String,Date）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">lastName:</span> <span class="string">liming</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;student.lastName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(lastName);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：加了@Value的类必须是交由Spring容器管理的</strong>（也就是说，必须有@RestController注解）</p></li><li><p><strong>@ConfigurationProperties注解：</strong>解决了@Value注解单个单个标注的弊端。 在类上添加注解@Component（将这个类注册到spring容器中）和@ConfigurationProperties(prefix &#x3D; “配置前缀”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：要求对应的属性要有set&#x2F;get方法，并且key要和成员变量名一致才可以对应的上。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lombok小使用</p><ul><li>安装插件，导入依赖</li><li>以下注解放在实体类上</li><li>@Data：生成getter&#x2F;setter方法</li><li>@AllArgsConstructor：提供全参构造</li><li>@NoArgsConstructor：提供无参构造</li></ul></li><li><p>yml小细节：</p><ul><li><p>yaml和properties可以相互转换，转换网站：<a href="https://www.toyaml.com/index.html">https://www.toyaml.com/index.html</a></p></li><li><p>配置提示：springboot会提醒你加配置提示</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221228160110149.png" alt="image-20221228160110149"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--打开网站添加注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加了之后重启一下项目（运行一下程序）就会有yml配置提示</p></li><li><p>工作中最常用的是配置其他框架的配置：<strong>千万注意数据类型！</strong>配置时ctrl按住左键，点进去，查看数据类型，填写正确的数据类型。</p></li></ul></li></ol></li></ol><h2 id="12-热部署"><a href="#12-热部署" class="headerlink" title="12.热部署"></a>12.热部署</h2><ol><li><p>dev-tools：启动时间短，重启更快</p></li><li><p>idea自动编译打开，然后允许程序运行期间自动重启</p></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>触发自动编译：打开其他软件（比如浏览器）小小等待一下，idea在后台自动编译。</p></li><li><p>没触发的话build project或者ctrl+f9</p></li></ol><h2 id="13-SpringBoot整合Junit"><a href="#13-SpringBoot整合Junit" class="headerlink" title="13.SpringBoot整合Junit"></a>13.SpringBoot整合Junit</h2><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写测试类：写在test文件夹下的java文件夹中创建包，要与启动类的结构一致（因为SpringBoot是从启动类所在的路径开始扫描文件的）</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sangeng.controller.HelloController;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//如果测试类放的包的位置不对可以将注解改成指定启动类如：@SpringBootTest(classes = Application.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloController helloController;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJunit</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">        System.out.println(helloController);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>测试类的作用：就是从spring容器中获取mapper或者service来测试功能，需要获取一下：就是@Autowired或者@Resource自动注入一下。后面一般是测试service。</p></li><li><p>如何兼容老版本？(junit4和junit5差别较大)：2.2.0之前的springboot就是默认junit4，怎么兼容呢?—&gt;</p></li></ol><ul><li>将原来的import的路径删掉，引入旧的。</li><li>在<code>@SpringBootTest</code>注解下添加一个<code>@RunWith(SpringRunner.class)</code>注解，才能在容器中获取的到</li></ul><p> 老版本如何兼容新版本？</p><p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221229102118768.png" alt="image-20221229102118768"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221229103255010.png" alt="image-20221229103255010"></p><ul><li><p>所以我们需要添加vintage依赖来兼容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加好了之后，老版本自动兼容，直接运行就好</p></li><li><p>总之：<strong>org.junit.Test对应的是Junit4的版本，就搭配@RunWith注解来使用。</strong>使用场景：<strong>之前代码是老版本不想做过多修改就用这套方法。</strong>新项目不用管。</p></li></ul></li></ol><h2 id="14-SpringBoot整合MyBatis"><a href="#14-SpringBoot整合MyBatis" class="headerlink" title="14.SpringBoot整合MyBatis"></a>14.SpringBoot整合MyBatis</h2><ol><li><p>准备工作：创建数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Table structure for table `user` */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Data for the table `user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `<span class="keyword">user</span>`(`id`,`username`,`age`,`address`) <span class="keyword">values</span> (<span class="number">2</span>,<span class="string">&#x27;pdd&#x27;</span>,<span class="number">25</span>,<span class="string">&#x27;上海&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;UZI&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;上海11&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;RF&#x27;</span>,<span class="number">19</span>,<span class="keyword">NULL</span>),(<span class="number">6</span>,<span class="string">&#x27;三更&#x27;</span>,<span class="number">14</span>,<span class="string">&#x27;请问2&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;test1&#x27;</span>,<span class="number">11</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;test2&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;cc2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建对应实体类</p></li><li><p>整合mybatis</p><ul><li><p>添加依赖：注意需要自己写版本号（因为不是官方的），查看官方文档写版本号，github: <a href="https://github.com/mybatis/spring-boot-starter/">https://github.com/mybatis/spring-boot-starter/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis启动器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在yaml配置数据库信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>配置mybatis相关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*Mapper.xml</span> <span class="comment"># mapper映射文件路径</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.sangeng.domain</span>   <span class="comment"># 配置哪个包下的类有默认的别名</span></span><br></pre></td></tr></table></figure></li><li><p>写接口在<strong>com.xxx.mapper包</strong>中：<strong>注意加上@Mapper 和@Repository这俩注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意加上这俩注解</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写&#x2F;mybatisx插件生成在<strong>resource&#x2F;mapper文件夹</strong>中，编写mapper接口对应的xml文件<em>xxMapper</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sangeng.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sangeng.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">&lt;/mapper</span><br></pre></td></tr></table></figure></li><li><p>编写junit测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = HelloApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tesMapper</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(userMapper.findAll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注：idea小问题（虽然运行没问题）–&gt;因为视频在测试的时候mapper接口没有添加**@Repository注解<strong>，springboot找不到注入的对应的bean，实际上mybatis整合包帮我们自动注入了已经。—&gt;解决方法，加</strong>@Repository注解**：标识是什么层（比如controller加@Controller注解），把对应的对象放到spring容器中。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221229120554458.png" alt="image-20221229120554458"></p></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb笔记</title>
      <link href="/2022/12/24/JavaWeb%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/24/JavaWeb%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaWeb笔记"><a href="#JavaWeb笔记" class="headerlink" title="JavaWeb笔记"></a>JavaWeb笔记</h1><hr><h2 id="1-js简单复习"><a href="#1-js简单复习" class="headerlink" title="1. js简单复习"></a>1. js简单复习</h2><h3 id="1-鼠标悬停效果实现"><a href="#1-鼠标悬停效果实现" class="headerlink" title="1. 鼠标悬停效果实现"></a>1. 鼠标悬停效果实现</h3><ol><li><p>在head标签中的script标签中引入</p></li><li><p>在tr标签中： onmouseover&#x3D;”调用的方法()”</p></li><li><p>方法中的event：当前发生的事件，event.srcElement：事件源</p></li><li><p>onmouseout：当鼠标离开时</p></li><li><p>系统提供的对象：window：当前浏览器窗口，窗口显示的所有内容叫document(给定浏览器窗口中的html文档)，浏览器上面的导航栏叫location</p></li><li><p>&#96;&#96;&#96;js<br>window.onload&#x3D;fuction(){<br>&#x2F;&#x2F;当页面加载完成，需要绑定各种事件，举例：<br>var fruitTabl&#x3D;document.getElementById(“tb_fruit”);  &#x2F;&#x2F;通过document对象获取fruit表<br>var rows&#x3D;fruitTabl.rows;&#x2F;&#x2F;获取表格行数<br>for(var i&#x3D;0;i&lt;rows.length;i++){<br>    var tr&#x3D;rows[i];&#x2F;&#x2F;循环获取每一行的所有列<br>    tr.onmouseover&#x3D;showBGColor;&#x2F;&#x2F;1.绑定鼠标悬浮设置背景颜色事件（事件绑定）<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.更新单价</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">## 2.servlet</span><br><span class="line"></span><br><span class="line">### 1.tomcat</span><br><span class="line"></span><br><span class="line">![image-20221105154230267](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221105154230267.png)</span><br><span class="line"></span><br><span class="line">### 2.快速入门</span><br><span class="line"></span><br><span class="line">1. 获取参数：用户在网站输入发请求：如`action=add`</span><br><span class="line">2. 项目中*web.xml*找到`url-pattern= /add` 然后找到`servlet-name = AddServlet`，找到和`servlet-mapping`中同名的`servlet-name`，然后找`servlet-class`的路径来找到对应的类</span><br><span class="line">3. 看用户发送的请求，用户发送的是`method = post`请求，故tomcat会执行servlet类中的`doPost`方法![image-20221106155105816](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221106155105816.png)</span><br><span class="line"></span><br><span class="line">4. 新建项目：</span><br><span class="line"></span><br><span class="line">- 新建模块，在模块中添加web模块，创建arctifact-部署包（war包：web项目的压缩包）</span><br><span class="line">- lib-artifact：现有artifact，后来才添加jar包（javaapi的包），此时，jar包并没有添加到部署包中。在projectStructure中会有提示。在problems中的fix可以添加。</span><br><span class="line">- 默认的`localhost/项目`访问的是欢迎页`index.xml`，在tomcat中的web.xml可以设置&lt;welcome-file-list&gt;标签里面的值来更改欢迎页访问谁，默认是`index.html`。或者在自己的web.xml中设置也行。</span><br><span class="line"></span><br><span class="line">5. 修改请求参数中的中文乱码问题：</span><br><span class="line"></span><br><span class="line">- post方式下`String fname = request.getParameter(&quot;fname&quot;)`之前，需要先设置一下编码，`request.setCharacterEncoding(&quot;UTF-8&quot;)` (request就是浏览器的请求，对应这个项目就是表单提交请求，也就是点击添加按钮)。</span><br><span class="line">- get方式基于tomcat8，不需要设置编码。</span><br><span class="line">- 注意：设置编码那句话必须在获取参数之前，否则已经获取到乱码了就不能再改了。</span><br><span class="line"></span><br><span class="line">### 3.servlet继承关系以及service方法</span><br><span class="line"></span><br><span class="line">1. ![image-20221106164526027](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221106164526027.png)</span><br><span class="line"></span><br><span class="line">2. ![image-20221106164715063](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221106164715063.png)</span><br><span class="line"></span><br><span class="line">3. **service方法：**</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  String method = req.getMethod();//获取请求的方式</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>获取完之后，if判断，请求是哪个就执行 <code>doXXX</code>方法。</p></li><li><p>当执行方法时，默认你重写了父类的doXXX方法，而重写的方法是<code>super.(req,res)</code>即默认是调用父类的方法。或者你没写doXXX方法，也会调用父类的方法。而父类的方法会通过获取协议值来判断是否<code>sendError(405/400,msg)</code>msg是通过support的key值来获取的报错信息。</p></li></ul><ol start="4"><li>servlet的生命周期：</li></ol><ul><li><p>servlet是tomcat容器帮我们去维护，自动调用方法</p></li><li><p>生命周期：从出生到死亡的过程，init()初始化——–&gt;service()服务———&gt;destroy()销毁。</p></li><li><p>只有第一次发请求的时候会初始化，即调用init()方法。servlet会进行实例化，初始化，然后服务，service()。</p></li><li><p>容器的销毁会调用destroy()销毁方法</p></li><li><p>Servlet实例tomcat，只会创建一个，所有的请求都是这个实例去响应。默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务。可以提高系统的启动速度。缺点：第一次请求时耗时较长。</p></li><li><p>如果想提高初始化速度，可以设置servlet的初始化时机：在servlet标签中添加<load-on-startup>标签，将标签内容设置为1，数字越小，启动的时间越靠前。设置了1之后tomcat直接启动并且创建。</p></li><li><p>servlet在容器中是单例的（单个的实例，不管几个请求，都是同一个），线程不安全的。线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变代。线程不安全，我们尽量不要在servlet中定义成员变量的值，不得不定义的话也不要去修改成员变量的值。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107092104315.png" alt="image-20221107092104315"></p></li></ul><h3 id="4-HTTP协议"><a href="#4-HTTP协议" class="headerlink" title="4.HTTP协议"></a>4.HTTP协议</h3><h4 id="1-请求和响应："><a href="#1-请求和响应：" class="headerlink" title="1.请求和响应："></a>1.请求和响应：</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107140510757.png" alt="image-20221107140510757"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107140904530.png" alt="image-20221107140904530"></p><h4 id="2-会话："><a href="#2-会话：" class="headerlink" title="2.会话："></a>2.会话：</h4><h5 id="1-http无状态："><a href="#1-http无状态：" class="headerlink" title="1. http无状态："></a>1. http无状态：</h5><ul><li>HTTP会无状态，服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的。</li><li>现实问题举例：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，就会导致混乱。</li><li>如何解决？——————-&gt;通过会话跟踪技术来解决无状态的问题。</li></ul><h5 id="2-会话跟踪技术："><a href="#2-会话跟踪技术：" class="headerlink" title="2.会话跟踪技术："></a>2.会话跟踪技术：</h5><ul><li>客户端第一次发请求给服务器，服务器会找请求要session（服务器获取session），获取不到，则创建新的，然后告诉客户端他的sessionid是什么（服务器响应给客户端）</li><li>下次客户端给服务器发送请求时，会把sessionid带给服务器，服务器这次获取就可以获取到，那么服务器就判断这次请求是不是和之前的某次请求时同一客户端，从而区分不同的客户端，解决http无状态的问题。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107143752797.png" alt="image-20221107143752797"></li></ul><h5 id="3-保存作用域："><a href="#3-保存作用域：" class="headerlink" title="3.保存作用域："></a>3.保存作用域：</h5><ul><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107145642266.png" alt="image-20221107145642266"></p></li><li><p>同一客户端的（浏览器）session可以互相获取，不同的不行。同一webapp可以获取，不同的不行。session的作用域保存session的id和k，v值，可以存放n个kv值，但是重命名key，value值会被覆盖掉。</p></li></ul><h5 id="4-内部转发和重定向"><a href="#4-内部转发和重定向" class="headerlink" title="4.内部转发和重定向"></a>4.内部转发和重定向</h5><ul><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107150233141.png" alt="image-20221107150233141"></p></li><li><p>服务器内部转发：一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的。地址栏没有变化。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107151946455.png" alt="image-20221107151946455"></p></li><li><p>重定向：两次请求响应的过程，客户端肯定知道URL有变化。地址栏有变化。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107152107657.png" alt="image-20221107152107657"></p></li></ul><h3 id="5-Thymeleaf-视图模板技术"><a href="#5-Thymeleaf-视图模板技术" class="headerlink" title="5. Thymeleaf-视图模板技术"></a>5. Thymeleaf-视图模板技术</h3><h4 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107154822964.png" alt="image-20221107154822964"></p><ul><li>servlet从3.0开始支持注解方式的注册，在servlet类前直接标注<code>@WebServlet（&quot;/路径&quot;）</code>，省去在web.xml中配置映射路径等步骤。</li><li>Thymeleaf：添加jar包，然后再在web.xml文件中配置。然后cv  ViewBaseServlet：processTemplate方法，处理模板——&gt;完成资源的转发和数据的渲染。</li><li>然后在web.xml中添加配置，配置视图前后缀。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107163539552.png" alt="image-20221107163539552"></li></ul><h4 id="2-渲染index页面"><a href="#2-渲染index页面" class="headerlink" title="2.渲染index页面"></a>2.渲染index页面<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107170518192.png" alt="image-20221107170518192"></h4><ul><li>通过thymeleaf语法，判断session中的fruitList是否为空。不为空：将list中的每一个元素迭代取出来。在每一列进行渲染，数据库中取出的元素动态放在对应的列。</li></ul><h4 id="3-thymeleaf-review"><a href="#3-thymeleaf-review" class="headerlink" title="3.thymeleaf review"></a>3.thymeleaf review</h4><p>知识点集合，上面都有，略。</p><h4 id="4-保存作用域"><a href="#4-保存作用域" class="headerlink" title="4.保存作用域"></a>4.保存作用域</h4><ol><li>原始情况下，我们认为有四个：page（页面级别，现在几乎不用)，request(一次请求响应范围),session(一次会话范围)，application(整个应用程序范围）</li><li><ul><li>request：一次请求响应范围：第一个重定向取不到值，因为是重定向，相当于两次响应。第二个可以取到值，因为是请求转发，一次响应，故可以取到值。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109142143712.png" alt="image-20221109142143712"></li><li>session：一次会话范围，只要session没有过期失效，不管采取的是哪种方式，都可以获取到。但是面对图下情况，两个客户端分别访问不同的servlet，不可以获取到，因为不是同一个session。 <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109143129002.png" alt="image-20221109143129002"></li><li>application：整个应用程序范围，相当于是公共的，不同客户端都可以取到。需要获取application保存作用域保存的数据：servlet上下文<code>ServletContext application = request.getServletContext();</code><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109144201882.png" alt="image-20221109144201882"></li></ul></li></ol><h4 id="5-路径问题"><a href="#5-路径问题" class="headerlink" title="5.路径问题"></a>5.路径问题</h4><p>相对路径和绝对路径，略。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109151417746.png" alt="image-20221109151417746">需要注意的是可以写成下面那两行那样的：@{}就相当于<code>localhost：8080/pro10/</code>了</p><h4 id="6-小实战1（2-3-4跳）"><a href="#6-小实战1（2-3-4跳）" class="headerlink" title="6.小实战1（2 3 4跳）"></a>6.小实战1（2 3 4跳）</h4><ol><li>只要不是<em><strong>form表单提交，或者method&#x3D;post</strong></em>，都是<em><strong>get请求</strong></em>。</li><li>隐藏域：功能类似于文本框，它的值会随着表单的发送也会发送给服务器，但是界面上看不到。</li></ol><h4 id="7-review-和234有关"><a href="#7-review-和234有关" class="headerlink" title="7.review(和234有关)"></a>7.review(和234有关)</h4><h3 id="6-servlet-mvc优化（重要）"><a href="#6-servlet-mvc优化（重要）" class="headerlink" title="6.servlet-mvc优化（重要）"></a>6.servlet-mvc优化（重要）</h3><h4 id="1-旧的结构："><a href="#1-旧的结构：" class="headerlink" title="1.旧的结构："></a>1.旧的结构：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110110700389.png" alt="image-20221110110700389"></h4><h4 id="2-新的结构："><a href="#2-新的结构：" class="headerlink" title="2.新的结构："></a>2.新的结构：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110144853740.png" alt="image-20221110144853740"></h4><ul><li>将几个servlet进行功能集合：将增删改查几个功能做成方法集成在一个servlet中。</li><li>通过if判断：如果请求是空的，那么就赋给请求”index”，进入index页面。如果请求不是空的，进入switch语句判断：是什么就进入对应什么的页面。</li></ul><h4 id="3-修改："><a href="#3-修改：" class="headerlink" title="3.修改："></a>3.修改：</h4><p>不用switch语句，而用method属性进行获取方法，遍历methods方法列表进行if判断：如果方法名和operate值相等，就用反射执行这个语句。但是会有弊端：这只是一个servlet中遍历各种方法，如果是多个servlet呢？每个servlet都要写反射吗？——&gt;引出<strong>DispatcherServlet：核心控制器&#x2F;中央控制器</strong>：处理所有请求，根据请求的不同来赋值给后面的不同servlet，再根据不同的servlet赋值给不同的方法上去。</p><h4 id="4-引出mvc原理："><a href="#4-引出mvc原理：" class="headerlink" title="4.引出mvc原理："></a>4.<em><strong>引出mvc原理</strong></em>：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110153737609.png" alt="image-20221110153737609"></h4><ol><li>servlet接收<code>*.do</code>:意思是所有的访问请求都会由这个servlet进行接收处理。</li><li>获取该请求的servletpath，比如 &#x2F;hello.do</li><li>进行字符串截取：&#x2F;hello.do——&gt;hello</li><li>对应下级servlet（controller）：hello——–&gt;helloController，此时helloservlet将不复存在，而是把原来的servlet类改为普通类。<em><strong>那么如何对应controller？</strong></em>：通过配置文件<em><strong>applicationContext.xml</strong></em>进行约定——&gt;JavaBeans:设置<bean>标签的id和class属性，作用：servletPath中涉及的名字对应的是你设置的这个id，就用class路径对应的controller类来处理。<em><strong>约定好了applicationContext.xml如何将DispatcherServlet联系起来？</strong></em>——–&gt;通过DispatcherServlet的构造方法，用流获取applicationContext.xml文件的内容：然后<ul><li>创建DocumentBuilderFactory对象</li><li>创建DocumentBuilder对象</li><li>创建Document对象（org.3c.dom）,传入配置文件的流。</li><li>获取所有的bean节点：调用对象的方法getElementsByTagId并传入bean，得到beanNodeList</li><li>for循环这个List获取每一个节点然后进行if判断，如果这个节点是元素节点，就获取它的id和name属性，通过name（全类名），找到它的对象，<strong>再把id和这个对象存入hashmap中（即解析好后放入map容器中）</strong>。</li><li><em><strong>总结：</strong></em>这样通过<bean>中的标签设定，通过DispatcherServlet能直接由路径找到对应的controller，然后再用笔记6.3中的步骤（<em><strong>赋operate的值</strong></em>），获取这个controller中的对应方法，然后反射执行，<strong>即：设置<bean>标签中的id和controller的全类名，就可以直接通过访问路径来执行对应controller。</strong><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110171221576.png" alt="image-20221110171221576"></li></ul></li></ol><h4 id="5-提取视图资源通用代码："><a href="#5-提取视图资源通用代码：" class="headerlink" title="5.提取视图资源通用代码："></a>5.提取视图资源通用代码：</h4><p>继续修改：</p><ul><li>因为controller中每个方法都要重定向，不妨放在DispatcherServlet进行统一调度：即controller中方法结束直接return “redirect:xxx页面”（视频中的更新功能要给用户展示更新后的界面，因此更新方法最后需要跳转进入fruit界面，也就是刷新一下fruit界面）</li><li>然后在DispatcherServlet获取该方法的反射调用后的返回值</li><li>然后进行视图处理：也就是在DispatcherServlet中进行真正的重定向。如果返回值没有redirect前缀，则直接进入页面。</li></ul><h4 id="6-在DispatcherServlet中统一获取参数以及视图处理："><a href="#6-在DispatcherServlet中统一获取参数以及视图处理：" class="headerlink" title="6.在DispatcherServlet中统一获取参数以及视图处理："></a>6.在DispatcherServlet中统一获取参数以及视图处理：</h4><ol><li>将在controller中的各种方法中的<code>request.getParameter(&quot;xxx&quot;)</code>删除，转而在形参列表获取参数（此时还没有将request中的字段和形参列表的参数联合起来），降低耦合。</li><li>在DispatcherServlet中统一获取参数：先for循环获取所有方法，然后每个方法用<code>method.getParameters()</code>获取当前方法的形参，返回的是数组，需要设置（因为数组中显示的是arg0，arg1…而不是显示形参的名字：在idea中设置build–&gt;java compiler<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221112140308195.png" alt="image-20221112140308195">并且添加如图参数)，这样就能获取方法的形参。</li><li>再遍历<code>2.</code>中获取的数组，循环得到方法的名字（<code>2.</code>中返回的是对象）</li><li>再判断获取的形参属于什么类型（request？response？session？），那么就不是通过请求中获取参数的方式了。</li><li><strong>总结：在controller中不需要先获取request中的parameter了，只需在形参列表规定好，DispatcherServlet会自动获取。</strong></li></ol><h4 id="7-总结："><a href="#7-总结：" class="headerlink" title="7.总结："></a>7.总结：</h4><h5 id="1-优化总结："><a href="#1-优化总结：" class="headerlink" title="1.优化总结："></a>1.优化总结：</h5><ol><li>开始是一个请求对应一个servlet，会导致servlet过多——&gt;<strong>用一个servlet判断，通过operate的值来决定调用servlet中的哪个方法(controller)。</strong></li><li>servlet如何调用方法？—–&gt;<strong>判断operate的赋的值和方法名是否一致：一致就反射调用，否则抛异常。</strong></li><li>每个servlet都反射，如何优化？—-&gt;<strong>设置中央控制器DispatcherServlet</strong></li><li>DispatcherServlet都有何功能？——&gt;</li></ol><h5 id="2-DispatcherServlet的功能："><a href="#2-DispatcherServlet的功能：" class="headerlink" title="2.DispatcherServlet的功能："></a>2.<strong>DispatcherServlet的功能：</strong></h5><ol><li><ul><li><strong>通过访问路径和读取applicationContext.xml</strong>(通过dom技术去解析xml文件，在中央控制器形成一个beanMap容器，用来存放所有的Controller组件)<strong>的设置，匹配到对应controller。</strong></li><li><strong>然后根据operate的值，通过反射调用controller中的对应方法。</strong></li></ul></li><li><ul><li>获取参数，也就是<strong>直接读取形参列表的参数，直接在形参列表设置要读取的request字段</strong>：获取即将要调用的方法的参数签名信息存放在数组，然后获取名称，参数值。通过获取类型，还要考虑类型转换。</li><li><strong>执行方法</strong>：通过反射执行方法。</li><li>视图处理：获取反射的返回值，如果返回值的字符串匹配”redirect:xxx”，就重定向哪，否则匹配xxx，就…，以此类推。也就是<strong>根据方法的返回值字符串来完成跳转的操作。</strong></li></ul></li></ol><h3 id="7-servlet-api"><a href="#7-servlet-api" class="headerlink" title="7.servlet-api"></a>7.servlet-api</h3><h4 id="1-servlet初始化："><a href="#1-servlet初始化：" class="headerlink" title="1.servlet初始化："></a>1.servlet初始化：</h4><ul><li>如果我们想在servlet初始化阶段带一些值，可以重写init()。</li><li>前提是要在web.xml中的servlet标签中配置<init-param>的kv值，然后再init方法中获取config对象，获取初始化参数值（v值）。</li><li>或者使用注解也可以，<code>@WebServlet(urlPatterns=&#123;&quot;xxxx&quot;&#125;,initParams=&#123;@WebInitParam(name=&quot;xxx&quot;,value=&quot;xxx&quot;),@WebInitParam....以此类推&#125;)</code></li></ul><h4 id="2-servlet上下文设置一些值："><a href="#2-servlet上下文设置一些值：" class="headerlink" title="2.servlet上下文设置一些值："></a>2.servlet上下文设置一些值：</h4><ul><li>在web.xml中配置<context-param>，设置kv值。可以再初始化中获取：getServletContext()。</li><li>在服务方法中也可以通过request对象获取：req.getSession.getServletContext。</li><li>获取初始化值servletContext.getInitParameter()。</li></ul><h2 id="3-mvc-service的引入"><a href="#3-mvc-service的引入" class="headerlink" title="3.mvc-service的引入"></a>3.mvc-service的引入</h2><ol><li>什么是业务层：</li></ol><ul><li>model1(jsp)和model2(mvc),mvc：<em><strong>mode</strong>l(有很多种，简单的pojo，难的如业务模型组件，数据访问层组件：</em>*pojo&#x2F;vo，dao,bo**，bo是业务模型组件),<strong>view</strong>(视图，网页，和用户交互),<strong>controller</strong>(控制器，接待请求)*。</li><li>区分业务对象和数据访问对象：dao中的方法都是<strong>单精度方法</strong>（一个方法只考虑一个操作），bo中的方法是复杂的业务方法，如注册功能，需要多个dao方法的组合调用，才能完成这个功能。</li></ul><ol start="2"><li>引入业务层<strong>（重点）</strong>：</li></ol><ul><li><p><strong>为什么要有业务层？</strong>：以前调用controller里面的各种业务方法，业务方法里还有很多dao层方法重复写，会让controller方法代码冗余。现在在controller层和dao层中添加service层，<strong>许多dao层方法的调用集合到service层</strong>，<strong>controller层调用service层的方法</strong>实现更复杂的业务逻辑。实现了解耦。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221114094409956.png" alt="image-20221114094409956"></p></li><li><p><strong>ioc</strong>：<strong>耦合&#x2F;依赖</strong>：层与层的设计是依赖的，不能离开，也叫耦合。系统架构和设计的一个原则是：<em>高内聚，低耦合。</em></p></li><li><p>以前是在controller中new xxxServiceImpl，才能调用service方法，现在为了降低耦合———&gt;如何做？</p></li><li><p><strong>如何反射创建对象？</strong>—-&gt;io流读取applicationContext.xml，创建document对象，获取bean节点，放入map容器中。（前文中有讲过）</p></li><li><p><strong>原理1（重点！）</strong>：在applicationContext.xml中配置bean，bean就是组件，spring通过<strong>控制反转</strong>（<strong>创建好Map容器，反射创建对象，放入map中，key是对象名，value是创建好的对象。</strong>beanFacatory接口中定义getbean方法，在ClassPathXmlApplicationContext中实现：<strong>根据id从map容器中获取对象</strong>。），bean的id是对象名，class是哪个类的对象。</p></li><li><p>修改dispatcherservlet：在其中的初始化方法中添加beanFactory对象，即当dispatcherservlet加载时自动创建beanFactory对象。</p></li><li><p><strong>原理2（原理1是知道了需要哪些组件，但是还不知道组件和组件之间的关系）</strong>：在<bean>标签中设置属性，即用<property>标签设置：<name>是属性名，<ref>是引用其他bean的id值。即描述<strong>bean之间的调用关系</strong>。</p></li><li><p><property>标签的<strong>调用关系是怎么实现</strong>的？——&gt;承接上文，在ClassPathXmlApplicationContext中获取对象之后，需要组装bean之间的依赖关系：for循环拿到每一个bean（map中的对象），读取bean中的内容（怎么读取？再次for循环，判断是否为元素节点并且节点名是否为property，然后取出name属性和ref属性），通过ref的值找到对应的对象（<strong>在map中找到那个ref的bean对象，这个叫对象a</strong>），然后给当前bean对象的name属性赋值（<strong>在map中找到当前对象，叫对象b</strong>）。获取当前对象（b）的属性，并改为ref对象（a）的属性。简单来说就是，<strong>引用谁（ref哪个类）要赋给谁（bean中的属性名name）。</strong></p></li><li><p>**在bean类中：Ref  name &#x3D; new ref()**。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221114152258719.png" alt="image-20221114152258719"></p></li></ul><ol start="3"><li>总结：<strong>控制反转（ioc）和依赖注入（di）</strong>： 以上。</li></ol><h2 id="4-filter过滤器"><a href="#4-filter过滤器" class="headerlink" title="4.filter过滤器"></a>4.filter过滤器</h2><ol><li>在客户端和servlet中间有过滤器<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116160715963.png" alt="image-20221116160715963">客户端发来请求和接收响应，浏览器执行请求和进行响应都会经过过滤器。</li><li>如何实现过滤器？——&gt; servlet类实现 Filter（注意是javax.servlet.Filter的包），配置<code>@WebFilter(&quot;拦截路径&quot;)</code>也可以在web.xml中添加路径，和servlet一样，只是servlet换成filter。</li><li>如何<strong>放行</strong>？——-&gt;重写doFilter方法，<code>filterChain.doFilter(servletreq..,servletrsp..)</code>然后执行service</li><li>当执行完响应时，又会拦截住，执行<code>filterChain.doFilter</code>这句话之后的代码。</li><li>可以设置通配符，如 *.do ，表示 .do结尾的都拦截。</li><li>过滤器链：过滤器的角色不一样，每个过滤器各司其职。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116162920268.png" alt="image-20221116162920268">要配置链的话，<strong>注解按全类名排序顺序，xml配置文件按配置的顺序。</strong></li><li>过滤器的应用：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116163631858.png" alt="image-20221116163631858"></li><li>事务管理的应用：</li></ol><ul><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116165721420.png" alt="image-20221116165721420"></p></li><li><p>所以事务管理就不能在dao层进行操作，需要在service层进行管理：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116170127588.png" alt="image-20221116170127588"></p></li><li><p>继续将事务管理提前<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116171002030.png" alt="image-20221116171002030"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116171253056.png" alt="image-20221116171253056">因为之前需要同一个connection，所以使用threadlocal来管理，设置好conn，之后get即可。</p></li><li><p>事务管理涉及到的组件：</p><p>OpenSessionInviewFilter<br>TransactionManager</p><p>ThreadLoca</p><p>ConnUtil<br>BaseDAO</p></li></ul><ol start="9"><li>ThreadLocal</li></ol><ul><li>本地线程：我们可以通过set方法在当前线程上存储数据、通过get方法在当前线程上获取数据。get(),set(obj)</li></ul><h3 id="4-01-Listener监听器"><a href="#4-01-Listener监听器" class="headerlink" title="4.01 Listener监听器"></a>4.01 Listener监听器</h3><p>1. </p><ul><li><p>servletContextListener：监听<strong>servletContext对象</strong>的创建和销毁的过程（观察者模式）。</p></li><li><p>HttpSessionListener-监听HttpSession对象的创建和销毁的过程。</p></li><li><p>ServletRequestListener-监听ServletRequest对象的创建和销毁的过程。</p></li></ul><p>2. </p><ul><li>ServletContextAttributeListener-监听ServletContext的保存作用域的改动（add,remove,replace）</li><li>HttpsessionAttributeListener-监听Httpsession的保存作用域的改动(add,remove,replace)</li><li>ServletRequestAttributeListener-监听ServletRequest的保存作用域的改动(add,remove,replace)</li></ul><p>3. </p><ul><li>HttpsessionBindingListener-监听某个对象在Sessioni域中的创建与移除</li><li>HttpSessionActivationListener-监听某个对象在Sessioni域中的序列化和反序列化</li></ul><ol start="4"><li>用哪个listener，servlet实现对应的接口，重写方法，加<code>@WebListener</code>注解，或者在web.xml中配置:<listener>标签。</li><li>监听上下文启动，在上下文启动的时候去创建虹oc容器，然后将其保存到application作用域。后面中央控制器再从application作用域中去获取IOC容器。</li><li><strong>dao组件有多个方法，同一个线程，才能共享数据，可以从线程上面获取。（像旋转火锅）</strong></li></ol><h3 id="4-02大总结"><a href="#4-02大总结" class="headerlink" title="4.02大总结"></a>4.02大总结</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116214218150.png" alt="image-20221116214218150"></p><h2 id="5-QQZone"><a href="#5-QQZone" class="headerlink" title="5.QQZone"></a>5.QQZone</h2><h2 id="6-书城"><a href="#6-书城" class="headerlink" title="6.书城"></a>6.书城</h2><h2 id="7-Cookie"><a href="#7-Cookie" class="headerlink" title="7.Cookie"></a>7.Cookie</h2><ol><li><p>什么是cookie？—–&gt;浏览器分配给客户端的session id是以cookie的形式保存的。<strong>cookie是在客户端保存数据的，session是在服务器端保存数据的。</strong></p></li><li><p>怎么保存数据？——&gt;创建cookie并保存：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221114161229856.png" alt="image-20221114161229856"></p></li><li><p>设置cookie的有效时长为60秒：cookie.setMaxAge(60)。</p></li><li><p>cookie的path和domain:随着本地cookie越来越多，每次访问时不能全把cookie带上。浏览器会通过这两个属性和访问地址作比较，从而决定是否携带这个cookie。</p><p><code>cookie.setDomain (pattern);</code><br><code>cookie.setpath(url);</code></p></li><li><p>cookie的应用：记住用户名和密码，免登录等等。注意cookie是保存在本地的，所以最好在自己的设备上保存。</p></li></ol><h3 id="6-kaptcha技术："><a href="#6-kaptcha技术：" class="headerlink" title="6.kaptcha技术："></a>6.kaptcha技术：</h3><ol><li>验证码：为什么需要？—–&gt;防止恶意攻击。</li><li>如何使用？——&gt;在web.xml文件中注册KaptchaServlet，并设置验证码图片的相关属性。</li><li>在html中设置一个img标签，设置src等于KaptchaServlet对应的url-pattern</li><li>kaptcha验证码图片的各个属性在常量接口：Constants中</li><li>KaptchaServlet在生成验证码图片时，会同时将验证码信息保存到session中<br>因此，我们在注册请求时，首先用户文本框中输入的验证码值和session中保存的值进行比较，相等，则进行注册。</li></ol><h2 id="8-正则表达式（8和8以下js）"><a href="#8-正则表达式（8和8以下js）" class="headerlink" title="8.正则表达式（8和8以下js）"></a>8.正则表达式（8和8以下js）</h2><ol><li>定义正则表达式对象：</li></ol><ul><li>对象形式<code>var reg = new RegExp(&quot;abc&quot;)</code></li><li>直接量形式<code>var reg = /abv/</code></li><li>匹配模式：g全局匹配，i忽略大小写匹配，m多行匹配，gim可以组合使用（不区分先后顺序）。<code>var reg = new RegExp(&quot;abc&quot;，&quot;gim&quot;);</code>,<code>var reg = /abv/igm;</code>意思相同。</li></ul><ol><li>定义待校验的字符串</li><li>校验</li><li>元字符：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117103833384.png" alt="image-20221117103833384"></li><li>字符集合：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117104406045.png" alt="image-20221117104406045">中括号[ ]：若目标字符串有中括号中的<strong>任意一个</strong>就可以匹配。不加中括号必须精确匹配，如&#x2F;abc&#x2F;，目标字符串必须有连续的abc才行。</li></ol><p>​中括号加小尖号^,表示目标字符串有除括号内以外的才匹配。</p><p>-：表示范围，从哪儿到哪儿。</p><ol start="5"><li>出现次数：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117105110911.png" alt="image-20221117105110911"></li><li>或者：|</li><li>常用正则表达式：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117105612026.png" alt="image-20221117105612026"></li><li>注意：一般使用正则表达式，百度就行。</li></ol><h2 id="9-Vue"><a href="#9-Vue" class="headerlink" title="9.Vue"></a>9.Vue</h2><ol><li><p>传统js创建对象的两种方式：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117110334903.png" alt="image-20221117110334903"></p></li><li><p>vue创建对象的的方式：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117110634735.png" alt="image-20221117110634735">快速定位操作的对象，省去了传统的获取步骤。</p></li><li><p>绑定元素的属性：v-bind表示绑定value属性，v-bind可以省略，直接写成：  。v-model表示双向绑定：以前msg的值决定输入框的内容，现在v-model可以让输入框的值来改变msg</p></li><li><p>v-model：value可以直接写成，v-model&#x3D;xxx。trim可以去除首尾空格：v-model.trim&#x3D;xxx。输入框内容的首尾空格会被去除掉。</p></li><li><p>v-if,v-else,v-show:if-else可以进行编程操作，但是v-if和v-else之间不能有其他节点。v-show:根据&#x3D;的值的true或false来决定display的值（也就是显示或者不显示）。</p></li><li><p>迭代v-for：语法v-for&#x3D;”xxx in xxx”，for循环。</p></li><li><p>v-on，事件驱动与事件绑定：之前是onclick：”方法”，现在v-on:click&#x3D; “方法”（注意在这儿的方法意思是调用，不能加()，加了括号意思是方法的返回值）。split（”x”）：意思是以x分割，若什么都不写就是把每个字符都分割。v-on:click可以简写为@click</p></li><li><p>&#96;&#96;&#96;js<br>var vue &#x3D; new Vue({<br>data:{&#x2F;&#x2F;自己定义的变量<br>    msg:”hello”<br>}<br>methods:{<br>    xxx:function(){&#x2F;&#x2F;自己定义的方法名<br>        this.msg.spilt(“”).reverse().join(“”)&#x2F;&#x2F;翻转字符串<br>    }<br>}<br>})</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. function(event)可以获取鼠标坐标：![image-20221117163406629](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117163406629.png)</span><br><span class="line"></span><br><span class="line">10. 侦听属性：watch</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">xxx:function(newValue)&#123; //监视xxx这个属性的变化，如果它变了，就继续操作。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>11.vue对象的生命周期：对象创建之前和之后，数据装配之前之后，数据加载之前之后</p><h2 id="10-Axios"><a href="#10-Axios" class="headerlink" title="10.Axios"></a>10.Axios</h2><ol><li>Axios是Ajax的一个框架，简化Ajax的操作。</li><li>Axios执行Ajax的操作步骤：</li></ol><ul><li><p>添加并引入axios的js文件。</p></li><li><p>客户端向服务器端异步发送参数值。</p></li><li><p>如何发送？——-&gt;前端部分：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130190747659.png" alt="image-20221130190747659">后端部分：接收打印<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191159733.png" alt="image-20221130191159733"></p></li><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191328468.png" alt="image-20221130191328468"></p></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191337967.png" alt="image-20221130191337967"></p><ul><li>当点击按钮触发axios时，axios会发送一个带普通请求参数值的异步请求，服务器端接收。</li><li>那么如何进行响应？——&gt;设置编码然后响应<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191748047.png" alt="image-20221130191748047"></li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130192047993.png" alt="image-20221130192047993">前端接收打印结果（成功响应时进行，否则catch），有问题会执行catch（异常处理)。</li></ul><ol start="3"><li>发送的请求体是json格式（客户端向服务器发送的是json格式的数据）：</li></ol><ul><li>json：是一种数据格式，kv值显示，有点类似python的字典。json表达数据更简单。json很灵活，内容可以是各种数据类型，可以是对象，可以是json嵌套。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130204753250.png" alt="image-20221130204753250"></li><li>重点：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130211007627.png" alt="image-20221130211007627"></li><li>如何使用：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130210828093.png" alt="image-20221130210828093"></li><li>若user是从数据库查出来的，需要将java对象转换为json格式的字符串，响应给客户端<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130211646041.png" alt="image-20221130211646041">mime-type是告诉浏览器响应的是什么数据。</li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212114478.png" alt="image-20221130212114478"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212304770.png" alt="image-20221130212304770"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212330368.png" alt="image-20221130212330368"></li><li>前后端分离：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212431746.png" alt="image-20221130212431746"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hsp JavaSE复习</title>
      <link href="/2022/12/23/JavaSE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/23/JavaSE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaSE复习"><a href="#JavaSE复习" class="headerlink" title="JavaSE复习"></a>JavaSE复习</h1><hr><h2 id="1-对象的多态（核心，重点）"><a href="#1-对象的多态（核心，重点）" class="headerlink" title="1.对象的多态（核心，重点）"></a>1.对象的多态（核心，重点）</h2><p><strong>1.对象编译类型和运行类型可以不一致，<em>可以让父类的引用指向子类的对象</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><p><em>等号左边编译类型，右边运行类型</em>（编译就是javac的时候，运行就是真正运行的时候）</p><p><strong>2.编译类型在定义对象时就确定了，不能改变</strong></p><p>3.可以在形参列表直接声明父类引用，将子类对象传进去</p><hr><p>4.向上转型：父类的引用指向子类的对象（向上转型的本质），可以调用父类的所有成员（遵守访问权限），但是不能调用子类的成员</p><p>因为在编译阶段，（声明好了），能调用哪些成员，由编译类型决定。运行结果看子类，从子类开始查找方法并调用</p><hr><p>5.向下转型：子类类型  引用名 &#x3D;  （子类类型） 父类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span>(Cat) animal;</span><br></pre></td></tr></table></figure><p>只能强转父类引用，不能强转父类对象（因为对象已经在内存创建好了）</p><p>父类引用必需指向当前目标类型的对象(也就是说必须满足下面条件为前提，才能向上面那样写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><p>向下转型后就可以调用子类类型中的所有成员</p><hr><p>6.属性重写问题：属性没有重写一说，属性就看编译类型就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>脑筋急转弯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">System.out.println(base.count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">//父类</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//属性 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;<span class="comment">//子类 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//属性 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为10，因为属性看编译类型</p><p>7.instanceOf    用来判断<em><strong>对象的运行类型</strong></em>是不是某某类型或者是不是某某类型的子类类型</p><hr><h2 id="2-动态绑定机制-p315（非常重要）"><a href="#2-动态绑定机制-p315（非常重要）" class="headerlink" title="2.动态绑定机制 p315（非常重要）"></a>2.动态绑定机制 p315（非常重要）</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221015170815917.png" alt="image-20221015170815917"></p><ol><li><p>a的编译类型是A，运行类型是B，<em>当将B类的sum()方法注释掉时</em>，会自动找其父类A的sum()方法。</p></li><li><p>但是父类sum()方法中有调用一个getI方法，这时动态绑定（运用第一条机制，对象a和运行类型B绑定），会调用子类的getI方法。</p></li><li><p>但是子类（B类）的getI方法return i是return的B类定义的i（20），运用第二条机制，属性没有动态绑定，哪里声明，哪里使用。</p></li></ol><hr><h2 id="3-断点调试"><a href="#3-断点调试" class="headerlink" title="3.断点调试"></a>3.断点调试</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221015193625682.png" alt="image-20221015193625682"></p><ol><li><p>断点调试是在程序运行的状态下</p></li><li><ul><li><p>F7(跳入) F8(跳过) </p></li><li><p>shift+F8(跳出) F9(resume,执行到下一个断点)</p></li><li><p>F7：跳入方法内</p></li><li><p>F8: 逐行执行代码</p></li><li><p>shift+F8: 跳出方法</p></li></ul></li><li><p>图片从左到右：逐行执行（F8），进入到方法体内（F7），强制进入方法体内（alt+shift+F7），跳出方法（shift+F8）</p></li><li><p>左边从上到下：resume,执行到下一个断点（F9），stop</p></li><li><p>追源代码：有些jdk源码进不去，可以强制进去。</p></li><li><p>支持动态下断点：在程序运行过程中还可以下断点。</p></li></ol><hr><h2 id="4-Java反射机制"><a href="#4-Java反射机制" class="headerlink" title="4.Java反射机制"></a>4.Java反射机制</h2><ol><li><p>需求引出反射：根据properties配置文件的指定信息，创建对象并调用方法。</p></li><li><ul><li><p>首先要io流接收到类的路径，第一步，加载类，返回Class类型的对象cls</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br></pre></td></tr></table></figure></li><li><p>通过 cls 获取你加载得到的类的对象实例:此时的o的运行类型是cat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>通过cls获取你加载得到的类的  <em>方法名字</em> ，来找到对应的方法对象（在反射机制中，方法也可以看作对象）（io流获得的方法名传入）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br></pre></td></tr></table></figure></li><li><p>通过method1调用方法：即通过方法的对象来实现调用方法。</p></li><li><p>传统方法<code>对象.方法()</code>，反射机制<code>方法.invoke(对象)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method1.invoke(o);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>总结：框架&#x3D;反射+注解+设计模式，在不修改源码的情况下控制程序，符合设计模式的ocp原则（开闭原则：不修改源码，扩展功能）</p></li><li><p>反射原理图：</p></li></ol><ul><li><p>反射原理：执行期间借助于Reflection API取得任何类的内部信息（成员变量，构造器，成员方法），并能操作对象的属性和方法。</p></li><li><p>在加载类过后，堆中就会产生相应的Class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息。通过这个对象看到类的结构，就像镜子一样，故得名：<em>反射</em> 。</p></li><li><p>原理图：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221104110317798.png" alt="image-20221104110317798"></p></li><li><p>java反射的功能：</p><p>1.在运行时判断任意一个对象所属的类<br>2.在运行时构造任意一个类的对象<br>3.在运行时得到任意一个类所具有的成员变量和方法<br>4.在运行时调用任意一个对象的成员变量和方法<br>5.生成动态代理</p></li><li><p>反射相关的类：<br>1.java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象<br>2.java.lang.reflect.Method:代表类的方法，Method对象表示某个类的方法<br>3.java.lang.reflect.Field:代表类的成员变量（字段），Fild对象代表某个类的成员变量<br>4.java.lang.reflect.Constructor:代表类的构造方法，.Constructor代表某个类的构造方法<br>这些类在java.lang.reflection</p></li><li><p>cls.getConstructor(String.class)&#x2F;&#x2F;这里老师传入的String.classs，就是String类的Class对象，可以获得含参构造器</p></li></ul><ol start="5"><li>反射调用优化：<ul><li>优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机<br>制，框架技术就失去底层支撑。</li><li>缺点：使用反射基本是解释执行，对执行速度有影响。</li><li>优化，method，field，constructor对象都有setAccessible()方法。这个方法的作用是启动和禁用访问安全检查的开关：参数为true，反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</li></ul></li><li>Class类分析：<ul><li>Class也是类，继承了了Obejct类。</li><li>Class类不是new出来的，而是系统ClassLoder类的loadClass方法创建出来的。无论是new还是反射底层都会调用这一方法。</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次。</li><li>每个对象实例都会记得自己由哪个Class实例所生成。</li><li>通过Class类可以完整的得到一个类的结构，通过一系列api</li><li>常用方法：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221105101132831.png" alt="image-20221105101132831"></li><li>Class对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限）</li></ul></li><li>获取Class对象的六种方式：<ul><li>代码阶段：主要是通过<code>Class.forname(全类名)</code>获取。<em>前提</em>：已知一个类的全类名，且该类在类路径下。<em>场景</em>：多用于配置文件，读取类的全路径，加载类。</li><li>类加载阶段：通过<code>类.class</code>。该方式安全可靠，程序性能最高。<em>场景</em>：多用于参数传递，比如通过反射得到对应构造器对象。</li><li>运行阶段：<code>对象.getClass()</code>。</li><li>还可以类加载器获取0717</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
