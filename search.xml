<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hsp JavaSE复习</title>
      <link href="/2022/12/23/hsp-JavaSE%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/12/23/hsp-JavaSE%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaSE复习"><a href="#JavaSE复习" class="headerlink" title="JavaSE复习"></a>JavaSE复习</h1><hr><h2 id="1-对象的多态（核心，重点）"><a href="#1-对象的多态（核心，重点）" class="headerlink" title="1.对象的多态（核心，重点）"></a>1.对象的多态（核心，重点）</h2><p><strong>1.对象编译类型和运行类型可以不一致，<em>可以让父类的引用指向子类的对象</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><p><em>等号左边编译类型，右边运行类型</em>（编译就是javac的时候，运行就是真正运行的时候）</p><p><strong>2.编译类型在定义对象时就确定了，不能改变</strong></p><p>3.可以在形参列表直接声明父类引用，将子类对象传进去</p><hr><p>4.向上转型：父类的引用指向子类的对象（向上转型的本质），可以调用父类的所有成员（遵守访问权限），但是不能调用子类的成员</p><p>因为在编译阶段，（声明好了），能调用哪些成员，由编译类型决定。运行结果看子类，从子类开始查找方法并调用</p><hr><p>5.向下转型：子类类型  引用名 &#x3D;  （子类类型） 父类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span>(Cat) animal;</span><br></pre></td></tr></table></figure><p>只能强转父类引用，不能强转父类对象（因为对象已经在内存创建好了）</p><p>父类引用必需指向当前目标类型的对象(也就是说必须满足下面条件为前提，才能向上面那样写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><p>向下转型后就可以调用子类类型中的所有成员</p><hr><p>6.属性重写问题：属性没有重写一说，属性就看编译类型就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>脑筋急转弯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">System.out.println(base.count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">//父类</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//属性 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;<span class="comment">//子类 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//属性 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为10，因为属性看编译类型</p><p>7.instanceOf    用来判断<em><strong>对象的运行类型</strong></em>是不是某某类型或者是不是某某类型的子类类型</p><hr><h2 id="2-动态绑定机制-p315（非常重要）"><a href="#2-动态绑定机制-p315（非常重要）" class="headerlink" title="2.动态绑定机制 p315（非常重要）"></a>2.动态绑定机制 p315（非常重要）</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221015170815917.png" alt="image-20221015170815917"></p><ol><li><p>a的编译类型是A，运行类型是B，<em>当将B类的sum()方法注释掉时</em>，会自动找其父类A的sum()方法。</p></li><li><p>但是父类sum()方法中有调用一个getI方法，这时动态绑定（运用第一条机制，对象a和运行类型B绑定），会调用子类的getI方法。</p></li><li><p>但是子类（B类）的getI方法return i是return的B类定义的i（20），运用第二条机制，属性没有动态绑定，哪里声明，哪里使用。</p></li></ol><hr><h2 id="3-断点调试"><a href="#3-断点调试" class="headerlink" title="3.断点调试"></a>3.断点调试</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221015193625682.png" alt="image-20221015193625682"></p><ol><li><p>断点调试是在程序运行的状态下</p></li><li><ul><li><p>F7(跳入) F8(跳过) </p></li><li><p>shift+F8(跳出) F9(resume,执行到下一个断点)</p></li><li><p>F7：跳入方法内</p></li><li><p>F8: 逐行执行代码</p></li><li><p>shift+F8: 跳出方法</p></li></ul></li><li><p>图片从左到右：逐行执行（F8），进入到方法体内（F7），强制进入方法体内（alt+shift+F7），跳出方法（shift+F8）</p></li><li><p>左边从上到下：resume,执行到下一个断点（F9），stop</p></li><li><p>追源代码：有些jdk源码进不去，可以强制进去。</p></li><li><p>支持动态下断点：在程序运行过程中还可以下断点。</p></li></ol><hr><h2 id="4-Java反射机制"><a href="#4-Java反射机制" class="headerlink" title="4.Java反射机制"></a>4.Java反射机制</h2><ol><li><p>需求引出反射：根据properties配置文件的指定信息，创建对象并调用方法。</p></li><li><ul><li><p>首先要io流接收到类的路径，第一步，加载类，返回Class类型的对象cls</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br></pre></td></tr></table></figure></li><li><p>通过 cls 获取你加载得到的类的对象实例:此时的o的运行类型是cat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>通过cls获取你加载得到的类的  <em>方法名字</em> ，来找到对应的方法对象（在反射机制中，方法也可以看作对象）（io流获得的方法名传入）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br></pre></td></tr></table></figure></li><li><p>通过method1调用方法：即通过方法的对象来实现调用方法。</p></li><li><p>传统方法<code>对象.方法()</code>，反射机制<code>方法.invoke(对象)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method1.invoke(o);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>总结：框架&#x3D;反射+注解+设计模式，在不修改源码的情况下控制程序，符合设计模式的ocp原则（开闭原则：不修改源码，扩展功能）</p></li><li><p>反射原理图：</p></li></ol><ul><li><p>反射原理：执行期间借助于Reflection API取得任何类的内部信息（成员变量，构造器，成员方法），并能操作对象的属性和方法。</p></li><li><p>在加载类过后，堆中就会产生相应的Class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息。通过这个对象看到类的结构，就像镜子一样，故得名：<em>反射</em> 。</p></li><li><p>原理图：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221104110317798.png" alt="image-20221104110317798"></p></li><li><p>java反射的功能：</p><p>1.在运行时判断任意一个对象所属的类<br>2.在运行时构造任意一个类的对象<br>3.在运行时得到任意一个类所具有的成员变量和方法<br>4.在运行时调用任意一个对象的成员变量和方法<br>5.生成动态代理</p></li><li><p>反射相关的类：<br>1.java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象<br>2.java.lang.reflect.Method:代表类的方法，Method对象表示某个类的方法<br>3.java.lang.reflect.Field:代表类的成员变量（字段），Fild对象代表某个类的成员变量<br>4.java.lang.reflect.Constructor:代表类的构造方法，.Constructor代表某个类的构造方法<br>这些类在java.lang.reflection</p></li><li><p>cls.getConstructor(String.class)&#x2F;&#x2F;这里老师传入的String.classs，就是String类的Class对象，可以获得含参构造器</p></li></ul><ol start="5"><li>反射调用优化：<ul><li>优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机<br>制，框架技术就失去底层支撑。</li><li>缺点：使用反射基本是解释执行，对执行速度有影响。</li><li>优化，method，field，constructor对象都有setAccessible()方法。这个方法的作用是启动和禁用访问安全检查的开关：参数为true，反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</li></ul></li><li>Class类分析：<ul><li>Class也是类，继承了了Obejct类。</li><li>Class类不是new出来的，而是系统ClassLoder类的loadClass方法创建出来的。无论是new还是反射底层都会调用这一方法。</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次。</li><li>每个对象实例都会记得自己由哪个Class实例所生成。</li><li>通过Class类可以完整的得到一个类的结构，通过一系列api</li><li>常用方法：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221105101132831.png" alt="image-20221105101132831"></li><li>Class对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限）</li></ul></li><li>获取Class对象的六种方式：<ul><li>代码阶段：主要是通过<code>Class.forname(全类名)</code>获取。<em>前提</em>：已知一个类的全类名，且该类在类路径下。<em>场景</em>：多用于配置文件，读取类的全路径，加载类。</li><li>类加载阶段：通过<code>类.class</code>。该方式安全可靠，程序性能最高。<em>场景</em>：多用于参数传递，比如通过反射得到对应构造器对象。</li><li>运行阶段：<code>对象.getClass()</code>。</li><li>还可以类加载器获取0717</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
