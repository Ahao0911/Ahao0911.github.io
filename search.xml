<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaWeb笔记</title>
      <link href="/2022/12/24/JavaWeb%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/24/JavaWeb%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaWeb笔记"><a href="#JavaWeb笔记" class="headerlink" title="JavaWeb笔记"></a>JavaWeb笔记</h1><hr><h2 id="1-js简单复习"><a href="#1-js简单复习" class="headerlink" title="1. js简单复习"></a>1. js简单复习</h2><h3 id="1-鼠标悬停效果实现"><a href="#1-鼠标悬停效果实现" class="headerlink" title="1. 鼠标悬停效果实现"></a>1. 鼠标悬停效果实现</h3><ol><li><p>在head标签中的script标签中引入</p></li><li><p>在tr标签中： onmouseover&#x3D;”调用的方法()”</p></li><li><p>方法中的event：当前发生的事件，event.srcElement：事件源</p></li><li><p>onmouseout：当鼠标离开时</p></li><li><p>系统提供的对象：window：当前浏览器窗口，窗口显示的所有内容叫document(给定浏览器窗口中的html文档)，浏览器上面的导航栏叫location</p></li><li><p>&#96;&#96;&#96;js<br>window.onload&#x3D;fuction(){<br>&#x2F;&#x2F;当页面加载完成，需要绑定各种事件，举例：<br>var fruitTabl&#x3D;document.getElementById(“tb_fruit”);  &#x2F;&#x2F;通过document对象获取fruit表<br>var rows&#x3D;fruitTabl.rows;&#x2F;&#x2F;获取表格行数<br>for(var i&#x3D;0;i&lt;rows.length;i++){<br>    var tr&#x3D;rows[i];&#x2F;&#x2F;循环获取每一行的所有列<br>    tr.onmouseover&#x3D;showBGColor;&#x2F;&#x2F;1.绑定鼠标悬浮设置背景颜色事件（事件绑定）<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.更新单价</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">## 2.servlet</span><br><span class="line"></span><br><span class="line">### 1.tomcat</span><br><span class="line"></span><br><span class="line">![image-20221105154230267](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221105154230267.png)</span><br><span class="line"></span><br><span class="line">### 2.快速入门</span><br><span class="line"></span><br><span class="line">1. 获取参数：用户在网站输入发请求：如`action=add`</span><br><span class="line">2. 项目中*web.xml*找到`url-pattern= /add` 然后找到`servlet-name = AddServlet`，找到和`servlet-mapping`中同名的`servlet-name`，然后找`servlet-class`的路径来找到对应的类</span><br><span class="line">3. 看用户发送的请求，用户发送的是`method = post`请求，故tomcat会执行servlet类中的`doPost`方法![image-20221106155105816](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221106155105816.png)</span><br><span class="line"></span><br><span class="line">4. 新建项目：</span><br><span class="line"></span><br><span class="line">- 新建模块，在模块中添加web模块，创建arctifact-部署包（war包：web项目的压缩包）</span><br><span class="line">- lib-artifact：现有artifact，后来才添加jar包（javaapi的包），此时，jar包并没有添加到部署包中。在projectStructure中会有提示。在problems中的fix可以添加。</span><br><span class="line">- 默认的`localhost/项目`访问的是欢迎页`index.xml`，在tomcat中的web.xml可以设置&lt;welcome-file-list&gt;标签里面的值来更改欢迎页访问谁，默认是`index.html`。或者在自己的web.xml中设置也行。</span><br><span class="line"></span><br><span class="line">5. 修改请求参数中的中文乱码问题：</span><br><span class="line"></span><br><span class="line">- post方式下`String fname = request.getParameter(&quot;fname&quot;)`之前，需要先设置一下编码，`request.setCharacterEncoding(&quot;UTF-8&quot;)` (request就是浏览器的请求，对应这个项目就是表单提交请求，也就是点击添加按钮)。</span><br><span class="line">- get方式基于tomcat8，不需要设置编码。</span><br><span class="line">- 注意：设置编码那句话必须在获取参数之前，否则已经获取到乱码了就不能再改了。</span><br><span class="line"></span><br><span class="line">### 3.servlet继承关系以及service方法</span><br><span class="line"></span><br><span class="line">1. ![image-20221106164526027](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221106164526027.png)</span><br><span class="line"></span><br><span class="line">2. ![image-20221106164715063](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221106164715063.png)</span><br><span class="line"></span><br><span class="line">3. **service方法：**</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  String method = req.getMethod();//获取请求的方式</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>获取完之后，if判断，请求是哪个就执行 <code>doXXX</code>方法。</p></li><li><p>当执行方法时，默认你重写了父类的doXXX方法，而重写的方法是<code>super.(req,res)</code>即默认是调用父类的方法。或者你没写doXXX方法，也会调用父类的方法。而父类的方法会通过获取协议值来判断是否<code>sendError(405/400,msg)</code>msg是通过support的key值来获取的报错信息。</p></li></ul><ol start="4"><li>servlet的生命周期：</li></ol><ul><li><p>servlet是tomcat容器帮我们去维护，自动调用方法</p></li><li><p>生命周期：从出生到死亡的过程，init()初始化——–&gt;service()服务———&gt;destroy()销毁。</p></li><li><p>只有第一次发请求的时候会初始化，即调用init()方法。servlet会进行实例化，初始化，然后服务，service()。</p></li><li><p>容器的销毁会调用destroy()销毁方法</p></li><li><p>Servlet实例tomcat，只会创建一个，所有的请求都是这个实例去响应。默认情况下，第一次请求时，tomcat才会去实例化，初始化，然后再服务。可以提高系统的启动速度。缺点：第一次请求时耗时较长。</p></li><li><p>如果想提高初始化速度，可以设置servlet的初始化时机：在servlet标签中添加<load-on-startup>标签，将标签内容设置为1，数字越小，启动的时间越靠前。设置了1之后tomcat直接启动并且创建。</p></li><li><p>servlet在容器中是单例的（单个的实例，不管几个请求，都是同一个），线程不安全的。线程不安全：一个线程需要根据这个实例中的某个成员变量值去做逻辑判断。但是在中间某个时机，另一个线程改变了这个成员变量的值，从而导致第一个线程的执行路径发生了变代。线程不安全，我们尽量不要在servlet中定义成员变量的值，不得不定义的话也不要去修改成员变量的值。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107092104315.png" alt="image-20221107092104315"></p></li></ul><h3 id="4-HTTP协议"><a href="#4-HTTP协议" class="headerlink" title="4.HTTP协议"></a>4.HTTP协议</h3><h4 id="1-请求和响应："><a href="#1-请求和响应：" class="headerlink" title="1.请求和响应："></a>1.请求和响应：</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107140510757.png" alt="image-20221107140510757"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107140904530.png" alt="image-20221107140904530"></p><h4 id="2-会话："><a href="#2-会话：" class="headerlink" title="2.会话："></a>2.会话：</h4><h5 id="1-http无状态："><a href="#1-http无状态：" class="headerlink" title="1. http无状态："></a>1. http无状态：</h5><ul><li>HTTP会无状态，服务器无法判断这两次请求是同一个客户端发过来的，还是不同的客户端发过来的。</li><li>现实问题举例：第一次请求是添加商品到购物车，第二次请求是结账；如果这两次请求服务器无法区分是同一个用户的，就会导致混乱。</li><li>如何解决？——————-&gt;通过会话跟踪技术来解决无状态的问题。</li></ul><h5 id="2-会话跟踪技术："><a href="#2-会话跟踪技术：" class="headerlink" title="2.会话跟踪技术："></a>2.会话跟踪技术：</h5><ul><li>客户端第一次发请求给服务器，服务器会找请求要session（服务器获取session），获取不到，则创建新的，然后告诉客户端他的sessionid是什么（服务器响应给客户端）</li><li>下次客户端给服务器发送请求时，会把sessionid带给服务器，服务器这次获取就可以获取到，那么服务器就判断这次请求是不是和之前的某次请求时同一客户端，从而区分不同的客户端，解决http无状态的问题。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107143752797.png" alt="image-20221107143752797"></li></ul><h5 id="3-保存作用域："><a href="#3-保存作用域：" class="headerlink" title="3.保存作用域："></a>3.保存作用域：</h5><ul><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107145642266.png" alt="image-20221107145642266"></p></li><li><p>同一客户端的（浏览器）session可以互相获取，不同的不行。同一webapp可以获取，不同的不行。session的作用域保存session的id和k，v值，可以存放n个kv值，但是重命名key，value值会被覆盖掉。</p></li></ul><h5 id="4-内部转发和重定向"><a href="#4-内部转发和重定向" class="headerlink" title="4.内部转发和重定向"></a>4.内部转发和重定向</h5><ul><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107150233141.png" alt="image-20221107150233141"></p></li><li><p>服务器内部转发：一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的。地址栏没有变化。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107151946455.png" alt="image-20221107151946455"></p></li><li><p>重定向：两次请求响应的过程，客户端肯定知道URL有变化。地址栏有变化。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107152107657.png" alt="image-20221107152107657"></p></li></ul><h3 id="5-Thymeleaf-视图模板技术"><a href="#5-Thymeleaf-视图模板技术" class="headerlink" title="5. Thymeleaf-视图模板技术"></a>5. Thymeleaf-视图模板技术</h3><h4 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h4><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107154822964.png" alt="image-20221107154822964"></p><ul><li>servlet从3.0开始支持注解方式的注册，在servlet类前直接标注<code>@WebServlet（&quot;/路径&quot;）</code>，省去在web.xml中配置映射路径等步骤。</li><li>Thymeleaf：添加jar包，然后再在web.xml文件中配置。然后cv  ViewBaseServlet：processTemplate方法，处理模板——&gt;完成资源的转发和数据的渲染。</li><li>然后在web.xml中添加配置，配置视图前后缀。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107163539552.png" alt="image-20221107163539552"></li></ul><h4 id="2-渲染index页面"><a href="#2-渲染index页面" class="headerlink" title="2.渲染index页面"></a>2.渲染index页面<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221107170518192.png" alt="image-20221107170518192"></h4><ul><li>通过thymeleaf语法，判断session中的fruitList是否为空。不为空：将list中的每一个元素迭代取出来。在每一列进行渲染，数据库中取出的元素动态放在对应的列。</li></ul><h4 id="3-thymeleaf-review"><a href="#3-thymeleaf-review" class="headerlink" title="3.thymeleaf review"></a>3.thymeleaf review</h4><p>知识点集合，上面都有，略。</p><h4 id="4-保存作用域"><a href="#4-保存作用域" class="headerlink" title="4.保存作用域"></a>4.保存作用域</h4><ol><li>原始情况下，我们认为有四个：page（页面级别，现在几乎不用)，request(一次请求响应范围),session(一次会话范围)，application(整个应用程序范围）</li><li><ul><li>request：一次请求响应范围：第一个重定向取不到值，因为是重定向，相当于两次响应。第二个可以取到值，因为是请求转发，一次响应，故可以取到值。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109142143712.png" alt="image-20221109142143712"></li><li>session：一次会话范围，只要session没有过期失效，不管采取的是哪种方式，都可以获取到。但是面对图下情况，两个客户端分别访问不同的servlet，不可以获取到，因为不是同一个session。 <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109143129002.png" alt="image-20221109143129002"></li><li>application：整个应用程序范围，相当于是公共的，不同客户端都可以取到。需要获取application保存作用域保存的数据：servlet上下文<code>ServletContext application = request.getServletContext();</code><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109144201882.png" alt="image-20221109144201882"></li></ul></li></ol><h4 id="5-路径问题"><a href="#5-路径问题" class="headerlink" title="5.路径问题"></a>5.路径问题</h4><p>相对路径和绝对路径，略。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221109151417746.png" alt="image-20221109151417746">需要注意的是可以写成下面那两行那样的：@{}就相当于<code>localhost：8080/pro10/</code>了</p><h4 id="6-小实战1（2-3-4跳）"><a href="#6-小实战1（2-3-4跳）" class="headerlink" title="6.小实战1（2 3 4跳）"></a>6.小实战1（2 3 4跳）</h4><ol><li>只要不是<em><strong>form表单提交，或者method&#x3D;post</strong></em>，都是<em><strong>get请求</strong></em>。</li><li>隐藏域：功能类似于文本框，它的值会随着表单的发送也会发送给服务器，但是界面上看不到。</li></ol><h4 id="7-review-和234有关"><a href="#7-review-和234有关" class="headerlink" title="7.review(和234有关)"></a>7.review(和234有关)</h4><h3 id="6-servlet-mvc优化（重要）"><a href="#6-servlet-mvc优化（重要）" class="headerlink" title="6.servlet-mvc优化（重要）"></a>6.servlet-mvc优化（重要）</h3><h4 id="1-旧的结构："><a href="#1-旧的结构：" class="headerlink" title="1.旧的结构："></a>1.旧的结构：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110110700389.png" alt="image-20221110110700389"></h4><h4 id="2-新的结构："><a href="#2-新的结构：" class="headerlink" title="2.新的结构："></a>2.新的结构：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110144853740.png" alt="image-20221110144853740"></h4><ul><li>将几个servlet进行功能集合：将增删改查几个功能做成方法集成在一个servlet中。</li><li>通过if判断：如果请求是空的，那么就赋给请求”index”，进入index页面。如果请求不是空的，进入switch语句判断：是什么就进入对应什么的页面。</li></ul><h4 id="3-修改："><a href="#3-修改：" class="headerlink" title="3.修改："></a>3.修改：</h4><p>不用switch语句，而用method属性进行获取方法，遍历methods方法列表进行if判断：如果方法名和operate值相等，就用反射执行这个语句。但是会有弊端：这只是一个servlet中遍历各种方法，如果是多个servlet呢？每个servlet都要写反射吗？——&gt;引出<strong>DispatcherServlet：核心控制器&#x2F;中央控制器</strong>：处理所有请求，根据请求的不同来赋值给后面的不同servlet，再根据不同的servlet赋值给不同的方法上去。</p><h4 id="4-引出mvc原理："><a href="#4-引出mvc原理：" class="headerlink" title="4.引出mvc原理："></a>4.<em><strong>引出mvc原理</strong></em>：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110153737609.png" alt="image-20221110153737609"></h4><ol><li>servlet接收<code>*.do</code>:意思是所有的访问请求都会由这个servlet进行接收处理。</li><li>获取该请求的servletpath，比如 &#x2F;hello.do</li><li>进行字符串截取：&#x2F;hello.do——&gt;hello</li><li>对应下级servlet（controller）：hello——–&gt;helloController，此时helloservlet将不复存在，而是把原来的servlet类改为普通类。<em><strong>那么如何对应controller？</strong></em>：通过配置文件<em><strong>applicationContext.xml</strong></em>进行约定——&gt;JavaBeans:设置<bean>标签的id和class属性，作用：servletPath中涉及的名字对应的是你设置的这个id，就用class路径对应的controller类来处理。<em><strong>约定好了applicationContext.xml如何将DispatcherServlet联系起来？</strong></em>——–&gt;通过DispatcherServlet的构造方法，用流获取applicationContext.xml文件的内容：然后<ul><li>创建DocumentBuilderFactory对象</li><li>创建DocumentBuilder对象</li><li>创建Document对象（org.3c.dom）,传入配置文件的流。</li><li>获取所有的bean节点：调用对象的方法getElementsByTagId并传入bean，得到beanNodeList</li><li>for循环这个List获取每一个节点然后进行if判断，如果这个节点是元素节点，就获取它的id和name属性，通过name（全类名），找到它的对象，<strong>再把id和这个对象存入hashmap中（即解析好后放入map容器中）</strong>。</li><li><em><strong>总结：</strong></em>这样通过<bean>中的标签设定，通过DispatcherServlet能直接由路径找到对应的controller，然后再用笔记6.3中的步骤（<em><strong>赋operate的值</strong></em>），获取这个controller中的对应方法，然后反射执行，<strong>即：设置<bean>标签中的id和controller的全类名，就可以直接通过访问路径来执行对应controller。</strong><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221110171221576.png" alt="image-20221110171221576"></li></ul></li></ol><h4 id="5-提取视图资源通用代码："><a href="#5-提取视图资源通用代码：" class="headerlink" title="5.提取视图资源通用代码："></a>5.提取视图资源通用代码：</h4><p>继续修改：</p><ul><li>因为controller中每个方法都要重定向，不妨放在DispatcherServlet进行统一调度：即controller中方法结束直接return “redirect:xxx页面”（视频中的更新功能要给用户展示更新后的界面，因此更新方法最后需要跳转进入fruit界面，也就是刷新一下fruit界面）</li><li>然后在DispatcherServlet获取该方法的反射调用后的返回值</li><li>然后进行视图处理：也就是在DispatcherServlet中进行真正的重定向。如果返回值没有redirect前缀，则直接进入页面。</li></ul><h4 id="6-在DispatcherServlet中统一获取参数以及视图处理："><a href="#6-在DispatcherServlet中统一获取参数以及视图处理：" class="headerlink" title="6.在DispatcherServlet中统一获取参数以及视图处理："></a>6.在DispatcherServlet中统一获取参数以及视图处理：</h4><ol><li>将在controller中的各种方法中的<code>request.getParameter(&quot;xxx&quot;)</code>删除，转而在形参列表获取参数（此时还没有将request中的字段和形参列表的参数联合起来），降低耦合。</li><li>在DispatcherServlet中统一获取参数：先for循环获取所有方法，然后每个方法用<code>method.getParameters()</code>获取当前方法的形参，返回的是数组，需要设置（因为数组中显示的是arg0，arg1…而不是显示形参的名字：在idea中设置build–&gt;java compiler<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221112140308195.png" alt="image-20221112140308195">并且添加如图参数)，这样就能获取方法的形参。</li><li>再遍历<code>2.</code>中获取的数组，循环得到方法的名字（<code>2.</code>中返回的是对象）</li><li>再判断获取的形参属于什么类型（request？response？session？），那么就不是通过请求中获取参数的方式了。</li><li><strong>总结：在controller中不需要先获取request中的parameter了，只需在形参列表规定好，DispatcherServlet会自动获取。</strong></li></ol><h4 id="7-总结："><a href="#7-总结：" class="headerlink" title="7.总结："></a>7.总结：</h4><h5 id="1-优化总结："><a href="#1-优化总结：" class="headerlink" title="1.优化总结："></a>1.优化总结：</h5><ol><li>开始是一个请求对应一个servlet，会导致servlet过多——&gt;<strong>用一个servlet判断，通过operate的值来决定调用servlet中的哪个方法(controller)。</strong></li><li>servlet如何调用方法？—–&gt;<strong>判断operate的赋的值和方法名是否一致：一致就反射调用，否则抛异常。</strong></li><li>每个servlet都反射，如何优化？—-&gt;<strong>设置中央控制器DispatcherServlet</strong></li><li>DispatcherServlet都有何功能？——&gt;</li></ol><h5 id="2-DispatcherServlet的功能："><a href="#2-DispatcherServlet的功能：" class="headerlink" title="2.DispatcherServlet的功能："></a>2.<strong>DispatcherServlet的功能：</strong></h5><ol><li><ul><li><strong>通过访问路径和读取applicationContext.xml</strong>(通过dom技术去解析xml文件，在中央控制器形成一个beanMap容器，用来存放所有的Controller组件)<strong>的设置，匹配到对应controller。</strong></li><li><strong>然后根据operate的值，通过反射调用controller中的对应方法。</strong></li></ul></li><li><ul><li>获取参数，也就是<strong>直接读取形参列表的参数，直接在形参列表设置要读取的request字段</strong>：获取即将要调用的方法的参数签名信息存放在数组，然后获取名称，参数值。通过获取类型，还要考虑类型转换。</li><li><strong>执行方法</strong>：通过反射执行方法。</li><li>视图处理：获取反射的返回值，如果返回值的字符串匹配”redirect:xxx”，就重定向哪，否则匹配xxx，就…，以此类推。也就是<strong>根据方法的返回值字符串来完成跳转的操作。</strong></li></ul></li></ol><h3 id="7-servlet-api"><a href="#7-servlet-api" class="headerlink" title="7.servlet-api"></a>7.servlet-api</h3><h4 id="1-servlet初始化："><a href="#1-servlet初始化：" class="headerlink" title="1.servlet初始化："></a>1.servlet初始化：</h4><ul><li>如果我们想在servlet初始化阶段带一些值，可以重写init()。</li><li>前提是要在web.xml中的servlet标签中配置<init-param>的kv值，然后再init方法中获取config对象，获取初始化参数值（v值）。</li><li>或者使用注解也可以，<code>@WebServlet(urlPatterns=&#123;&quot;xxxx&quot;&#125;,initParams=&#123;@WebInitParam(name=&quot;xxx&quot;,value=&quot;xxx&quot;),@WebInitParam....以此类推&#125;)</code></li></ul><h4 id="2-servlet上下文设置一些值："><a href="#2-servlet上下文设置一些值：" class="headerlink" title="2.servlet上下文设置一些值："></a>2.servlet上下文设置一些值：</h4><ul><li>在web.xml中配置<context-param>，设置kv值。可以再初始化中获取：getServletContext()。</li><li>在服务方法中也可以通过request对象获取：req.getSession.getServletContext。</li><li>获取初始化值servletContext.getInitParameter()。</li></ul><h2 id="3-mvc-service的引入"><a href="#3-mvc-service的引入" class="headerlink" title="3.mvc-service的引入"></a>3.mvc-service的引入</h2><ol><li>什么是业务层：</li></ol><ul><li>model1(jsp)和model2(mvc),mvc：<em><strong>mode</strong>l(有很多种，简单的pojo，难的如业务模型组件，数据访问层组件：</em>*pojo&#x2F;vo，dao,bo**，bo是业务模型组件),<strong>view</strong>(视图，网页，和用户交互),<strong>controller</strong>(控制器，接待请求)*。</li><li>区分业务对象和数据访问对象：dao中的方法都是<strong>单精度方法</strong>（一个方法只考虑一个操作），bo中的方法是复杂的业务方法，如注册功能，需要多个dao方法的组合调用，才能完成这个功能。</li></ul><ol start="2"><li>引入业务层<strong>（重点）</strong>：</li></ol><ul><li><p><strong>为什么要有业务层？</strong>：以前调用controller里面的各种业务方法，业务方法里还有很多dao层方法重复写，会让controller方法代码冗余。现在在controller层和dao层中添加service层，<strong>许多dao层方法的调用集合到service层</strong>，<strong>controller层调用service层的方法</strong>实现更复杂的业务逻辑。实现了解耦。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221114094409956.png" alt="image-20221114094409956"></p></li><li><p><strong>ioc</strong>：<strong>耦合&#x2F;依赖</strong>：层与层的设计是依赖的，不能离开，也叫耦合。系统架构和设计的一个原则是：<em>高内聚，低耦合。</em></p></li><li><p>以前是在controller中new xxxServiceImpl，才能调用service方法，现在为了降低耦合———&gt;如何做？</p></li><li><p><strong>如何反射创建对象？</strong>—-&gt;io流读取applicationContext.xml，创建document对象，获取bean节点，放入map容器中。（前文中有讲过）</p></li><li><p><strong>原理1（重点！）</strong>：在applicationContext.xml中配置bean，bean就是组件，spring通过<strong>控制反转</strong>（<strong>创建好Map容器，反射创建对象，放入map中，key是对象名，value是创建好的对象。</strong>beanFacatory接口中定义getbean方法，在ClassPathXmlApplicationContext中实现：<strong>根据id从map容器中获取对象</strong>。），bean的id是对象名，class是哪个类的对象。</p></li><li><p>修改dispatcherservlet：在其中的初始化方法中添加beanFactory对象，即当dispatcherservlet加载时自动创建beanFactory对象。</p></li><li><p><strong>原理2（原理1是知道了需要哪些组件，但是还不知道组件和组件之间的关系）</strong>：在<bean>标签中设置属性，即用<property>标签设置：<name>是属性名，<ref>是引用其他bean的id值。即描述<strong>bean之间的调用关系</strong>。</p></li><li><p><property>标签的<strong>调用关系是怎么实现</strong>的？——&gt;承接上文，在ClassPathXmlApplicationContext中获取对象之后，需要组装bean之间的依赖关系：for循环拿到每一个bean（map中的对象），读取bean中的内容（怎么读取？再次for循环，判断是否为元素节点并且节点名是否为property，然后取出name属性和ref属性），通过ref的值找到对应的对象（<strong>在map中找到那个ref的bean对象，这个叫对象a</strong>），然后给当前bean对象的name属性赋值（<strong>在map中找到当前对象，叫对象b</strong>）。获取当前对象（b）的属性，并改为ref对象（a）的属性。简单来说就是，<strong>引用谁（ref哪个类）要赋给谁（bean中的属性名name）。</strong></p></li><li><p>**在bean类中：Ref  name &#x3D; new ref()**。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221114152258719.png" alt="image-20221114152258719"></p></li></ul><ol start="3"><li>总结：<strong>控制反转（ioc）和依赖注入（di）</strong>： 以上。</li></ol><h2 id="4-filter过滤器"><a href="#4-filter过滤器" class="headerlink" title="4.filter过滤器"></a>4.filter过滤器</h2><ol><li>在客户端和servlet中间有过滤器<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116160715963.png" alt="image-20221116160715963">客户端发来请求和接收响应，浏览器执行请求和进行响应都会经过过滤器。</li><li>如何实现过滤器？——&gt; servlet类实现 Filter（注意是javax.servlet.Filter的包），配置<code>@WebFilter(&quot;拦截路径&quot;)</code>也可以在web.xml中添加路径，和servlet一样，只是servlet换成filter。</li><li>如何<strong>放行</strong>？——-&gt;重写doFilter方法，<code>filterChain.doFilter(servletreq..,servletrsp..)</code>然后执行service</li><li>当执行完响应时，又会拦截住，执行<code>filterChain.doFilter</code>这句话之后的代码。</li><li>可以设置通配符，如 *.do ，表示 .do结尾的都拦截。</li><li>过滤器链：过滤器的角色不一样，每个过滤器各司其职。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116162920268.png" alt="image-20221116162920268">要配置链的话，<strong>注解按全类名排序顺序，xml配置文件按配置的顺序。</strong></li><li>过滤器的应用：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116163631858.png" alt="image-20221116163631858"></li><li>事务管理的应用：</li></ol><ul><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116165721420.png" alt="image-20221116165721420"></p></li><li><p>所以事务管理就不能在dao层进行操作，需要在service层进行管理：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116170127588.png" alt="image-20221116170127588"></p></li><li><p>继续将事务管理提前<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116171002030.png" alt="image-20221116171002030"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116171253056.png" alt="image-20221116171253056">因为之前需要同一个connection，所以使用threadlocal来管理，设置好conn，之后get即可。</p></li><li><p>事务管理涉及到的组件：</p><p>OpenSessionInviewFilter<br>TransactionManager</p><p>ThreadLoca</p><p>ConnUtil<br>BaseDAO</p></li></ul><ol start="9"><li>ThreadLocal</li></ol><ul><li>本地线程：我们可以通过set方法在当前线程上存储数据、通过get方法在当前线程上获取数据。get(),set(obj)</li></ul><h3 id="4-01-Listener监听器"><a href="#4-01-Listener监听器" class="headerlink" title="4.01 Listener监听器"></a>4.01 Listener监听器</h3><p>1. </p><ul><li><p>servletContextListener：监听<strong>servletContext对象</strong>的创建和销毁的过程（观察者模式）。</p></li><li><p>HttpSessionListener-监听HttpSession对象的创建和销毁的过程。</p></li><li><p>ServletRequestListener-监听ServletRequest对象的创建和销毁的过程。</p></li></ul><p>2. </p><ul><li>ServletContextAttributeListener-监听ServletContext的保存作用域的改动（add,remove,replace）</li><li>HttpsessionAttributeListener-监听Httpsession的保存作用域的改动(add,remove,replace)</li><li>ServletRequestAttributeListener-监听ServletRequest的保存作用域的改动(add,remove,replace)</li></ul><p>3. </p><ul><li>HttpsessionBindingListener-监听某个对象在Sessioni域中的创建与移除</li><li>HttpSessionActivationListener-监听某个对象在Sessioni域中的序列化和反序列化</li></ul><ol start="4"><li>用哪个listener，servlet实现对应的接口，重写方法，加<code>@WebListener</code>注解，或者在web.xml中配置:<listener>标签。</li><li>监听上下文启动，在上下文启动的时候去创建虹oc容器，然后将其保存到application作用域。后面中央控制器再从application作用域中去获取IOC容器。</li><li><strong>dao组件有多个方法，同一个线程，才能共享数据，可以从线程上面获取。（像旋转火锅）</strong></li></ol><h3 id="4-02大总结"><a href="#4-02大总结" class="headerlink" title="4.02大总结"></a>4.02大总结</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221116214218150.png" alt="image-20221116214218150"></p><h2 id="5-QQZone"><a href="#5-QQZone" class="headerlink" title="5.QQZone"></a>5.QQZone</h2><h2 id="6-书城"><a href="#6-书城" class="headerlink" title="6.书城"></a>6.书城</h2><h2 id="7-Cookie"><a href="#7-Cookie" class="headerlink" title="7.Cookie"></a>7.Cookie</h2><ol><li><p>什么是cookie？—–&gt;浏览器分配给客户端的session id是以cookie的形式保存的。<strong>cookie是在客户端保存数据的，session是在服务器端保存数据的。</strong></p></li><li><p>怎么保存数据？——&gt;创建cookie并保存：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221114161229856.png" alt="image-20221114161229856"></p></li><li><p>设置cookie的有效时长为60秒：cookie.setMaxAge(60)。</p></li><li><p>cookie的path和domain:随着本地cookie越来越多，每次访问时不能全把cookie带上。浏览器会通过这两个属性和访问地址作比较，从而决定是否携带这个cookie。</p><p><code>cookie.setDomain (pattern);</code><br><code>cookie.setpath(url);</code></p></li><li><p>cookie的应用：记住用户名和密码，免登录等等。注意cookie是保存在本地的，所以最好在自己的设备上保存。</p></li></ol><h3 id="6-kaptcha技术："><a href="#6-kaptcha技术：" class="headerlink" title="6.kaptcha技术："></a>6.kaptcha技术：</h3><ol><li>验证码：为什么需要？—–&gt;防止恶意攻击。</li><li>如何使用？——&gt;在web.xml文件中注册KaptchaServlet，并设置验证码图片的相关属性。</li><li>在html中设置一个img标签，设置src等于KaptchaServlet对应的url-pattern</li><li>kaptcha验证码图片的各个属性在常量接口：Constants中</li><li>KaptchaServlet在生成验证码图片时，会同时将验证码信息保存到session中<br>因此，我们在注册请求时，首先用户文本框中输入的验证码值和session中保存的值进行比较，相等，则进行注册。</li></ol><h2 id="8-正则表达式（8和8以下js）"><a href="#8-正则表达式（8和8以下js）" class="headerlink" title="8.正则表达式（8和8以下js）"></a>8.正则表达式（8和8以下js）</h2><ol><li>定义正则表达式对象：</li></ol><ul><li>对象形式<code>var reg = new RegExp(&quot;abc&quot;)</code></li><li>直接量形式<code>var reg = /abv/</code></li><li>匹配模式：g全局匹配，i忽略大小写匹配，m多行匹配，gim可以组合使用（不区分先后顺序）。<code>var reg = new RegExp(&quot;abc&quot;，&quot;gim&quot;);</code>,<code>var reg = /abv/igm;</code>意思相同。</li></ul><ol><li>定义待校验的字符串</li><li>校验</li><li>元字符：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117103833384.png" alt="image-20221117103833384"></li><li>字符集合：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117104406045.png" alt="image-20221117104406045">中括号[ ]：若目标字符串有中括号中的<strong>任意一个</strong>就可以匹配。不加中括号必须精确匹配，如&#x2F;abc&#x2F;，目标字符串必须有连续的abc才行。</li></ol><p>​中括号加小尖号^,表示目标字符串有除括号内以外的才匹配。</p><p>-：表示范围，从哪儿到哪儿。</p><ol start="5"><li>出现次数：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117105110911.png" alt="image-20221117105110911"></li><li>或者：|</li><li>常用正则表达式：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117105612026.png" alt="image-20221117105612026"></li><li>注意：一般使用正则表达式，百度就行。</li></ol><h2 id="9-Vue"><a href="#9-Vue" class="headerlink" title="9.Vue"></a>9.Vue</h2><ol><li><p>传统js创建对象的两种方式：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117110334903.png" alt="image-20221117110334903"></p></li><li><p>vue创建对象的的方式：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117110634735.png" alt="image-20221117110634735">快速定位操作的对象，省去了传统的获取步骤。</p></li><li><p>绑定元素的属性：v-bind表示绑定value属性，v-bind可以省略，直接写成：  。v-model表示双向绑定：以前msg的值决定输入框的内容，现在v-model可以让输入框的值来改变msg</p></li><li><p>v-model：value可以直接写成，v-model&#x3D;xxx。trim可以去除首尾空格：v-model.trim&#x3D;xxx。输入框内容的首尾空格会被去除掉。</p></li><li><p>v-if,v-else,v-show:if-else可以进行编程操作，但是v-if和v-else之间不能有其他节点。v-show:根据&#x3D;的值的true或false来决定display的值（也就是显示或者不显示）。</p></li><li><p>迭代v-for：语法v-for&#x3D;”xxx in xxx”，for循环。</p></li><li><p>v-on，事件驱动与事件绑定：之前是onclick：”方法”，现在v-on:click&#x3D; “方法”（注意在这儿的方法意思是调用，不能加()，加了括号意思是方法的返回值）。split（”x”）：意思是以x分割，若什么都不写就是把每个字符都分割。v-on:click可以简写为@click</p></li><li><p>&#96;&#96;&#96;js<br>var vue &#x3D; new Vue({<br>data:{&#x2F;&#x2F;自己定义的变量<br>    msg:”hello”<br>}<br>methods:{<br>    xxx:function(){&#x2F;&#x2F;自己定义的方法名<br>        this.msg.spilt(“”).reverse().join(“”)&#x2F;&#x2F;翻转字符串<br>    }<br>}<br>})</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. function(event)可以获取鼠标坐标：![image-20221117163406629](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221117163406629.png)</span><br><span class="line"></span><br><span class="line">10. 侦听属性：watch</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">xxx:function(newValue)&#123; //监视xxx这个属性的变化，如果它变了，就继续操作。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>11.vue对象的生命周期：对象创建之前和之后，数据装配之前之后，数据加载之前之后</p><h2 id="10-Axios"><a href="#10-Axios" class="headerlink" title="10.Axios"></a>10.Axios</h2><ol><li>Axios是Ajax的一个框架，简化Ajax的操作。</li><li>Axios执行Ajax的操作步骤：</li></ol><ul><li><p>添加并引入axios的js文件。</p></li><li><p>客户端向服务器端异步发送参数值。</p></li><li><p>如何发送？——-&gt;前端部分：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130190747659.png" alt="image-20221130190747659">后端部分：接收打印<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191159733.png" alt="image-20221130191159733"></p></li><li><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191328468.png" alt="image-20221130191328468"></p></li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191337967.png" alt="image-20221130191337967"></p><ul><li>当点击按钮触发axios时，axios会发送一个带普通请求参数值的异步请求，服务器端接收。</li><li>那么如何进行响应？——&gt;设置编码然后响应<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130191748047.png" alt="image-20221130191748047"></li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130192047993.png" alt="image-20221130192047993">前端接收打印结果（成功响应时进行，否则catch），有问题会执行catch（异常处理)。</li></ul><ol start="3"><li>发送的请求体是json格式（客户端向服务器发送的是json格式的数据）：</li></ol><ul><li>json：是一种数据格式，kv值显示，有点类似python的字典。json表达数据更简单。json很灵活，内容可以是各种数据类型，可以是对象，可以是json嵌套。<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130204753250.png" alt="image-20221130204753250"></li><li>重点：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130211007627.png" alt="image-20221130211007627"></li><li>如何使用：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130210828093.png" alt="image-20221130210828093"></li><li>若user是从数据库查出来的，需要将java对象转换为json格式的字符串，响应给客户端<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130211646041.png" alt="image-20221130211646041">mime-type是告诉浏览器响应的是什么数据。</li><li><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212114478.png" alt="image-20221130212114478"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212304770.png" alt="image-20221130212304770"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212330368.png" alt="image-20221130212330368"></li><li>前后端分离：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221130212431746.png" alt="image-20221130212431746"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hsp JavaSE复习</title>
      <link href="/2022/12/23/JavaSE%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/23/JavaSE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaSE复习"><a href="#JavaSE复习" class="headerlink" title="JavaSE复习"></a>JavaSE复习</h1><hr><h2 id="1-对象的多态（核心，重点）"><a href="#1-对象的多态（核心，重点）" class="headerlink" title="1.对象的多态（核心，重点）"></a>1.对象的多态（核心，重点）</h2><p><strong>1.对象编译类型和运行类型可以不一致，<em>可以让父类的引用指向子类的对象</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><p><em>等号左边编译类型，右边运行类型</em>（编译就是javac的时候，运行就是真正运行的时候）</p><p><strong>2.编译类型在定义对象时就确定了，不能改变</strong></p><p>3.可以在形参列表直接声明父类引用，将子类对象传进去</p><hr><p>4.向上转型：父类的引用指向子类的对象（向上转型的本质），可以调用父类的所有成员（遵守访问权限），但是不能调用子类的成员</p><p>因为在编译阶段，（声明好了），能调用哪些成员，由编译类型决定。运行结果看子类，从子类开始查找方法并调用</p><hr><p>5.向下转型：子类类型  引用名 &#x3D;  （子类类型） 父类引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span>(Cat) animal;</span><br></pre></td></tr></table></figure><p>只能强转父类引用，不能强转父类对象（因为对象已经在内存创建好了）</p><p>父类引用必需指向当前目标类型的对象(也就是说必须满足下面条件为前提，才能向上面那样写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure><p>向下转型后就可以调用子类类型中的所有成员</p><hr><p>6.属性重写问题：属性没有重写一说，属性就看编译类型就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>脑筋急转弯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">System.out.println(base.count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">//父类</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//属性 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;<span class="comment">//子类 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">//属性 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为10，因为属性看编译类型</p><p>7.instanceOf    用来判断<em><strong>对象的运行类型</strong></em>是不是某某类型或者是不是某某类型的子类类型</p><hr><h2 id="2-动态绑定机制-p315（非常重要）"><a href="#2-动态绑定机制-p315（非常重要）" class="headerlink" title="2.动态绑定机制 p315（非常重要）"></a>2.动态绑定机制 p315（非常重要）</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221015170815917.png" alt="image-20221015170815917"></p><ol><li><p>a的编译类型是A，运行类型是B，<em>当将B类的sum()方法注释掉时</em>，会自动找其父类A的sum()方法。</p></li><li><p>但是父类sum()方法中有调用一个getI方法，这时动态绑定（运用第一条机制，对象a和运行类型B绑定），会调用子类的getI方法。</p></li><li><p>但是子类（B类）的getI方法return i是return的B类定义的i（20），运用第二条机制，属性没有动态绑定，哪里声明，哪里使用。</p></li></ol><hr><h2 id="3-断点调试"><a href="#3-断点调试" class="headerlink" title="3.断点调试"></a>3.断点调试</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221015193625682.png" alt="image-20221015193625682"></p><ol><li><p>断点调试是在程序运行的状态下</p></li><li><ul><li><p>F7(跳入) F8(跳过) </p></li><li><p>shift+F8(跳出) F9(resume,执行到下一个断点)</p></li><li><p>F7：跳入方法内</p></li><li><p>F8: 逐行执行代码</p></li><li><p>shift+F8: 跳出方法</p></li></ul></li><li><p>图片从左到右：逐行执行（F8），进入到方法体内（F7），强制进入方法体内（alt+shift+F7），跳出方法（shift+F8）</p></li><li><p>左边从上到下：resume,执行到下一个断点（F9），stop</p></li><li><p>追源代码：有些jdk源码进不去，可以强制进去。</p></li><li><p>支持动态下断点：在程序运行过程中还可以下断点。</p></li></ol><hr><h2 id="4-Java反射机制"><a href="#4-Java反射机制" class="headerlink" title="4.Java反射机制"></a>4.Java反射机制</h2><ol><li><p>需求引出反射：根据properties配置文件的指定信息，创建对象并调用方法。</p></li><li><ul><li><p>首先要io流接收到类的路径，第一步，加载类，返回Class类型的对象cls</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br></pre></td></tr></table></figure></li><li><p>通过 cls 获取你加载得到的类的对象实例:此时的o的运行类型是cat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>通过cls获取你加载得到的类的  <em>方法名字</em> ，来找到对应的方法对象（在反射机制中，方法也可以看作对象）（io流获得的方法名传入）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br></pre></td></tr></table></figure></li><li><p>通过method1调用方法：即通过方法的对象来实现调用方法。</p></li><li><p>传统方法<code>对象.方法()</code>，反射机制<code>方法.invoke(对象)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method1.invoke(o);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>总结：框架&#x3D;反射+注解+设计模式，在不修改源码的情况下控制程序，符合设计模式的ocp原则（开闭原则：不修改源码，扩展功能）</p></li><li><p>反射原理图：</p></li></ol><ul><li><p>反射原理：执行期间借助于Reflection API取得任何类的内部信息（成员变量，构造器，成员方法），并能操作对象的属性和方法。</p></li><li><p>在加载类过后，堆中就会产生相应的Class类型的对象（一个类只有一个class对象），这个对象包含了类的完整结构信息。通过这个对象看到类的结构，就像镜子一样，故得名：<em>反射</em> 。</p></li><li><p>原理图：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221104110317798.png" alt="image-20221104110317798"></p></li><li><p>java反射的功能：</p><p>1.在运行时判断任意一个对象所属的类<br>2.在运行时构造任意一个类的对象<br>3.在运行时得到任意一个类所具有的成员变量和方法<br>4.在运行时调用任意一个对象的成员变量和方法<br>5.生成动态代理</p></li><li><p>反射相关的类：<br>1.java.lang.Class:代表一个类，Class对象表示某个类加载后在堆中的对象<br>2.java.lang.reflect.Method:代表类的方法，Method对象表示某个类的方法<br>3.java.lang.reflect.Field:代表类的成员变量（字段），Fild对象代表某个类的成员变量<br>4.java.lang.reflect.Constructor:代表类的构造方法，.Constructor代表某个类的构造方法<br>这些类在java.lang.reflection</p></li><li><p>cls.getConstructor(String.class)&#x2F;&#x2F;这里老师传入的String.classs，就是String类的Class对象，可以获得含参构造器</p></li></ul><ol start="5"><li>反射调用优化：<ul><li>优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机<br>制，框架技术就失去底层支撑。</li><li>缺点：使用反射基本是解释执行，对执行速度有影响。</li><li>优化，method，field，constructor对象都有setAccessible()方法。这个方法的作用是启动和禁用访问安全检查的开关：参数为true，反射的对象在使用时取消访问检查，提高反射效率。参数值为false表示反射的对象执行访问检查。</li></ul></li><li>Class类分析：<ul><li>Class也是类，继承了了Obejct类。</li><li>Class类不是new出来的，而是系统ClassLoder类的loadClass方法创建出来的。无论是new还是反射底层都会调用这一方法。</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次。</li><li>每个对象实例都会记得自己由哪个Class实例所生成。</li><li>通过Class类可以完整的得到一个类的结构，通过一系列api</li><li>常用方法：<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13671/image-20221105101132831.png" alt="image-20221105101132831"></li><li>Class对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限）</li></ul></li><li>获取Class对象的六种方式：<ul><li>代码阶段：主要是通过<code>Class.forname(全类名)</code>获取。<em>前提</em>：已知一个类的全类名，且该类在类路径下。<em>场景</em>：多用于配置文件，读取类的全路径，加载类。</li><li>类加载阶段：通过<code>类.class</code>。该方式安全可靠，程序性能最高。<em>场景</em>：多用于参数传递，比如通过反射得到对应构造器对象。</li><li>运行阶段：<code>对象.getClass()</code>。</li><li>还可以类加载器获取0717</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
